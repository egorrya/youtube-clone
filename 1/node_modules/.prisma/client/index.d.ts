
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime';

export import DMMF = runtime.DMMF

/**
 * Prisma Errors
 */
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export import sql = runtime.sqltag
export import empty = runtime.empty
export import join = runtime.join
export import raw = runtime.raw
export import Sql = runtime.Sql

/**
 * Decimal.js
 */
export import Decimal = runtime.Decimal

/**
 * Prisma Client JS version: 2.12.0
 * Query Engine version: cf0680a1bfe8d5e743dc659cc7f08009f9587d58
 */
export type PrismaVersion = {
  client: string
}

export const prismaVersion: PrismaVersion 

/**
 * Utility Types
 */

/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON object.
 * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
 */
export type JsonObject = {[Key in string]?: JsonValue}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON array.
 */
export interface JsonArray extends Array<JsonValue> {}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches any valid JSON value.
 */
export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

/**
 * Same as JsonObject, but allows undefined
 */
export type InputJsonObject = {[Key in string]?: JsonValue}
 
export interface InputJsonArray extends Array<JsonValue> {}
 
export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
 type SelectAndInclude = {
  select: any
  include: any
}
type HasSelect = {
  select: any
}
type HasInclude = {
  include: any
}
type CheckSelect<T, S, U> = T extends SelectAndInclude
  ? 'Please either choose `select` or `include`'
  : T extends HasSelect
  ? U
  : T extends HasInclude
  ? U
  : S

/**
 * Get the type of the value, that the Promise holds.
 */
export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

/**
 * Get the return type of a function which returns a Promise.
 */
export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>


export type Enumerable<T> = T | Array<T>;

export type RequiredKeys<T> = {
  [K in keyof T]-?: {} extends Pick<T, K> ? never : K
}[keyof T]

export type TruthyKeys<T> = {
  [key in keyof T]: T[key] extends false | undefined | null ? never : key
}[keyof T]

export type TrueKeys<T> = TruthyKeys<Pick<T, RequiredKeys<T>>>

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;





/**
 * Model User
 */

export type User = {
  id: string
  createdAt: Date
  username: string
  email: string
  avatar: string
  cover: string
  about: string
}

/**
 * Model Comment
 */

export type Comment = {
  id: string
  createdAt: Date
  text: string
  userId: string
  videoId: string
}

/**
 * Model Subscription
 */

export type Subscription = {
  id: string
  createdAt: Date
  subscriberId: string
  subscribedToId: string
}

/**
 * Model Video
 */

export type Video = {
  id: string
  createdAt: Date
  title: string
  description: string | null
  url: string
  thumbnail: string
  userId: string
}

/**
 * Model VideoLike
 */

export type VideoLike = {
  id: string
  createdAt: Date
  like: number
  userId: string
  videoId: string
}

/**
 * Model View
 */

export type View = {
  id: string
  createdAt: Date
  userId: string | null
  videoId: string
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: T);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): Promise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): Promise<T>;

  /**
   * Execute queries in a transaction
   * @example
   * ```
   * const [george, bob, alice] = await prisma.transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   */
  $transaction: PromiseConstructor['all']

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate;

  /**
   * `prisma.video`: Exposes CRUD operations for the **Video** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Videos
    * const videos = await prisma.video.findMany()
    * ```
    */
  get video(): Prisma.VideoDelegate;

  /**
   * `prisma.videoLike`: Exposes CRUD operations for the **VideoLike** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VideoLikes
    * const videoLikes = await prisma.videoLike.findMany()
    * ```
    */
  get videoLike(): Prisma.VideoLikeDelegate;

  /**
   * `prisma.view`: Exposes CRUD operations for the **View** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Views
    * const views = await prisma.view.findMany()
    * ```
    */
  get view(): Prisma.ViewDelegate;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export type PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export type PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 2.12.0
   * Query Engine version: cf0680a1bfe8d5e743dc659cc7f08009f9587d58
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

  /**
   * Same as JsonObject, but allows undefined
   */
  export type InputJsonObject = {[Key in string]?: JsonValue}
 
  export interface InputJsonArray extends Array<JsonValue> {}
 
  export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
   type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    User: 'User',
    Comment: 'Comment',
    Subscription: 'Subscription',
    Video: 'Video',
    VideoLike: 'VideoLike',
    View: 'View'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: string
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }


  /**
   * Model User
   */


  export type AggregateUser = {
    count: number
  }



  export type AggregateUserArgs = {
    where?: UserWhereInput
    orderBy?: XOR<Enumerable<UserOrderByInput>, UserOrderByInput>
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserDistinctFieldEnum>
    count?: true
  }

  export type GetUserAggregateType<T extends AggregateUserArgs> = {
    [P in keyof T]: P extends 'count' ? number : never
  }


    
    

  export type UserSelect = {
    id?: boolean
    createdAt?: boolean
    username?: boolean
    email?: boolean
    avatar?: boolean
    cover?: boolean
    about?: boolean
    videos?: boolean | FindManyVideoArgs
    videoLikes?: boolean | FindManyVideoLikeArgs
    comments?: boolean | FindManyCommentArgs
    subscribers?: boolean | FindManySubscriptionArgs
    subscribedTo?: boolean | FindManySubscriptionArgs
    views?: boolean | FindManyViewArgs
  }

  export type UserInclude = {
    videos?: boolean | FindManyVideoArgs
    videoLikes?: boolean | FindManyVideoLikeArgs
    comments?: boolean | FindManyCommentArgs
    subscribers?: boolean | FindManySubscriptionArgs
    subscribedTo?: boolean | FindManySubscriptionArgs
    views?: boolean | FindManyViewArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | FindManyUserArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'videos'
        ? Array < VideoGetPayload<S['include'][P]>>  :
        P extends 'videoLikes'
        ? Array < VideoLikeGetPayload<S['include'][P]>>  :
        P extends 'comments'
        ? Array < CommentGetPayload<S['include'][P]>>  :
        P extends 'subscribers'
        ? Array < SubscriptionGetPayload<S['include'][P]>>  :
        P extends 'subscribedTo'
        ? Array < SubscriptionGetPayload<S['include'][P]>>  :
        P extends 'views'
        ? Array < ViewGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof User ?User [P]
  : 
          P extends 'videos'
        ? Array < VideoGetPayload<S['select'][P]>>  :
        P extends 'videoLikes'
        ? Array < VideoLikeGetPayload<S['select'][P]>>  :
        P extends 'comments'
        ? Array < CommentGetPayload<S['select'][P]>>  :
        P extends 'subscribers'
        ? Array < SubscriptionGetPayload<S['select'][P]>>  :
        P extends 'subscribedTo'
        ? Array < SubscriptionGetPayload<S['select'][P]>>  :
        P extends 'views'
        ? Array < ViewGetPayload<S['select'][P]>>  : never
  } 
    : User
  : User


  export interface UserDelegate {
    /**
     * Find zero or one User that matches the filter.
     * @param {FindUniqueUserArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueUserArgs>(
      args: Subset<T, FindUniqueUserArgs>
    ): CheckSelect<T, Prisma__UserClient<User | null>, Prisma__UserClient<UserGetPayload<T> | null>>
    /**
     * Find the first User that matches the filter.
     * @param {FindFirstUserArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstUserArgs>(
      args?: Subset<T, FindFirstUserArgs>
    ): CheckSelect<T, Prisma__UserClient<User | null>, Prisma__UserClient<UserGetPayload<T> | null>>
    /**
     * Find zero or more Users that matches the filter.
     * @param {FindManyUserArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManyUserArgs>(
      args?: Subset<T, FindManyUserArgs>
    ): CheckSelect<T, Promise<Array<User>>, Promise<Array<UserGetPayload<T>>>>
    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: Subset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>
    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: Subset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>
    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: Subset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>
    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args: Subset<T, UserDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more Users.
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: Subset<T, UserUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: Subset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>
    /**
     * Find zero or one User that matches the filter.
     * @param {FindUniqueUserArgs} args - Arguments to find a User
     * @deprecated This will be deprecated please use prisma.user.findUnique
     * @example
     * // Get one User
     * const user = await prisma.user.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueUserArgs>(
      args: Subset<T, FindUniqueUserArgs>
    ): CheckSelect<T, Prisma__UserClient<User | null>, Prisma__UserClient<UserGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManyUserArgs, 'select' | 'include'>): Promise<number>

    /**
     * Aggregate
     */
    aggregate<T extends AggregateUserArgs>(args: Subset<T, AggregateUserArgs>): Promise<GetUserAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    videos<T extends FindManyVideoArgs = {}>(args?: Subset<T, FindManyVideoArgs>): CheckSelect<T, Promise<Array<Video>>, Promise<Array<VideoGetPayload<T>>>>;

    videoLikes<T extends FindManyVideoLikeArgs = {}>(args?: Subset<T, FindManyVideoLikeArgs>): CheckSelect<T, Promise<Array<VideoLike>>, Promise<Array<VideoLikeGetPayload<T>>>>;

    comments<T extends FindManyCommentArgs = {}>(args?: Subset<T, FindManyCommentArgs>): CheckSelect<T, Promise<Array<Comment>>, Promise<Array<CommentGetPayload<T>>>>;

    subscribers<T extends FindManySubscriptionArgs = {}>(args?: Subset<T, FindManySubscriptionArgs>): CheckSelect<T, Promise<Array<Subscription>>, Promise<Array<SubscriptionGetPayload<T>>>>;

    subscribedTo<T extends FindManySubscriptionArgs = {}>(args?: Subset<T, FindManySubscriptionArgs>): CheckSelect<T, Promise<Array<Subscription>>, Promise<Array<SubscriptionGetPayload<T>>>>;

    views<T extends FindManyViewArgs = {}>(args?: Subset<T, FindManyViewArgs>): CheckSelect<T, Promise<Array<View>>, Promise<Array<ViewGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type FindUniqueUserArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: XOR<UserSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<UserInclude, null>
    /**
     * Filter, which User to fetch.
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type FindFirstUserArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: XOR<UserSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<UserInclude, null>
    /**
     * Filter, which User to fetch.
    **/
    where?: UserWhereInput
    orderBy?: XOR<Enumerable<UserOrderByInput>, UserOrderByInput>
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserDistinctFieldEnum>
  }


  /**
   * User findMany
   */
  export type FindManyUserArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: XOR<UserSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<UserInclude, null>
    /**
     * Filter, which Users to fetch.
    **/
    where?: UserWhereInput
    /**
     * Determine the order of the Users to fetch.
    **/
    orderBy?: XOR<Enumerable<UserOrderByInput>, UserOrderByInput>
    /**
     * Sets the position for listing Users.
    **/
    cursor?: UserWhereUniqueInput
    /**
     * The number of Users to fetch. If negative number, it will take Users before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` Users.
    **/
    skip?: number
    distinct?: Enumerable<UserDistinctFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: XOR<UserSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<UserInclude, null>
    /**
     * The data needed to create a User.
    **/
    data: UserCreateInput
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: XOR<UserSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<UserInclude, null>
    /**
     * The data needed to update a User.
    **/
    data: UserUpdateInput
    /**
     * Choose, which User to update.
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    data: UserUpdateManyMutationInput
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: XOR<UserSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<UserInclude, null>
    /**
     * The filter to search for the User to update in case it exists.
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
    **/
    create: UserCreateInput
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
    **/
    update: UserUpdateInput
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: XOR<UserSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<UserInclude, null>
    /**
     * Filter which User to delete.
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: XOR<UserSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<UserInclude, null>
  }



  /**
   * Model Comment
   */


  export type AggregateComment = {
    count: number
  }



  export type AggregateCommentArgs = {
    where?: CommentWhereInput
    orderBy?: XOR<Enumerable<CommentOrderByInput>, CommentOrderByInput>
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CommentDistinctFieldEnum>
    count?: true
  }

  export type GetCommentAggregateType<T extends AggregateCommentArgs> = {
    [P in keyof T]: P extends 'count' ? number : never
  }


    
    

  export type CommentSelect = {
    id?: boolean
    createdAt?: boolean
    text?: boolean
    userId?: boolean
    videoId?: boolean
    user?: boolean | UserArgs
    video?: boolean | VideoArgs
  }

  export type CommentInclude = {
    user?: boolean | UserArgs
    video?: boolean | VideoArgs
  }

  export type CommentGetPayload<
    S extends boolean | null | undefined | CommentArgs,
    U = keyof S
      > = S extends true
        ? Comment
    : S extends undefined
    ? never
    : S extends CommentArgs | FindManyCommentArgs
    ?'include' extends U
    ? Comment  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> :
        P extends 'video'
        ? VideoGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Comment ?Comment [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> :
        P extends 'video'
        ? VideoGetPayload<S['select'][P]> : never
  } 
    : Comment
  : Comment


  export interface CommentDelegate {
    /**
     * Find zero or one Comment that matches the filter.
     * @param {FindUniqueCommentArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueCommentArgs>(
      args: Subset<T, FindUniqueCommentArgs>
    ): CheckSelect<T, Prisma__CommentClient<Comment | null>, Prisma__CommentClient<CommentGetPayload<T> | null>>
    /**
     * Find the first Comment that matches the filter.
     * @param {FindFirstCommentArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstCommentArgs>(
      args?: Subset<T, FindFirstCommentArgs>
    ): CheckSelect<T, Prisma__CommentClient<Comment | null>, Prisma__CommentClient<CommentGetPayload<T> | null>>
    /**
     * Find zero or more Comments that matches the filter.
     * @param {FindManyCommentArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManyCommentArgs>(
      args?: Subset<T, FindManyCommentArgs>
    ): CheckSelect<T, Promise<Array<Comment>>, Promise<Array<CommentGetPayload<T>>>>
    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
    **/
    create<T extends CommentCreateArgs>(
      args: Subset<T, CommentCreateArgs>
    ): CheckSelect<T, Prisma__CommentClient<Comment>, Prisma__CommentClient<CommentGetPayload<T>>>
    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
    **/
    delete<T extends CommentDeleteArgs>(
      args: Subset<T, CommentDeleteArgs>
    ): CheckSelect<T, Prisma__CommentClient<Comment>, Prisma__CommentClient<CommentGetPayload<T>>>
    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommentUpdateArgs>(
      args: Subset<T, CommentUpdateArgs>
    ): CheckSelect<T, Prisma__CommentClient<Comment>, Prisma__CommentClient<CommentGetPayload<T>>>
    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommentDeleteManyArgs>(
      args: Subset<T, CommentDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more Comments.
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommentUpdateManyArgs>(
      args: Subset<T, CommentUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
    **/
    upsert<T extends CommentUpsertArgs>(
      args: Subset<T, CommentUpsertArgs>
    ): CheckSelect<T, Prisma__CommentClient<Comment>, Prisma__CommentClient<CommentGetPayload<T>>>
    /**
     * Find zero or one Comment that matches the filter.
     * @param {FindUniqueCommentArgs} args - Arguments to find a Comment
     * @deprecated This will be deprecated please use prisma.comment.findUnique
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueCommentArgs>(
      args: Subset<T, FindUniqueCommentArgs>
    ): CheckSelect<T, Prisma__CommentClient<Comment | null>, Prisma__CommentClient<CommentGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManyCommentArgs, 'select' | 'include'>): Promise<number>

    /**
     * Aggregate
     */
    aggregate<T extends AggregateCommentArgs>(args: Subset<T, AggregateCommentArgs>): Promise<GetCommentAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommentClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null>, Prisma__UserClient<UserGetPayload<T> | null>>;

    video<T extends VideoArgs = {}>(args?: Subset<T, VideoArgs>): CheckSelect<T, Prisma__VideoClient<Video | null>, Prisma__VideoClient<VideoGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Comment findUnique
   */
  export type FindUniqueCommentArgs = {
    /**
     * Select specific fields to fetch from the Comment
    **/
    select?: XOR<CommentSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<CommentInclude, null>
    /**
     * Filter, which Comment to fetch.
    **/
    where: CommentWhereUniqueInput
  }


  /**
   * Comment findFirst
   */
  export type FindFirstCommentArgs = {
    /**
     * Select specific fields to fetch from the Comment
    **/
    select?: XOR<CommentSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<CommentInclude, null>
    /**
     * Filter, which Comment to fetch.
    **/
    where?: CommentWhereInput
    orderBy?: XOR<Enumerable<CommentOrderByInput>, CommentOrderByInput>
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CommentDistinctFieldEnum>
  }


  /**
   * Comment findMany
   */
  export type FindManyCommentArgs = {
    /**
     * Select specific fields to fetch from the Comment
    **/
    select?: XOR<CommentSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<CommentInclude, null>
    /**
     * Filter, which Comments to fetch.
    **/
    where?: CommentWhereInput
    /**
     * Determine the order of the Comments to fetch.
    **/
    orderBy?: XOR<Enumerable<CommentOrderByInput>, CommentOrderByInput>
    /**
     * Sets the position for listing Comments.
    **/
    cursor?: CommentWhereUniqueInput
    /**
     * The number of Comments to fetch. If negative number, it will take Comments before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` Comments.
    **/
    skip?: number
    distinct?: Enumerable<CommentDistinctFieldEnum>
  }


  /**
   * Comment create
   */
  export type CommentCreateArgs = {
    /**
     * Select specific fields to fetch from the Comment
    **/
    select?: XOR<CommentSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<CommentInclude, null>
    /**
     * The data needed to create a Comment.
    **/
    data: CommentCreateInput
  }


  /**
   * Comment update
   */
  export type CommentUpdateArgs = {
    /**
     * Select specific fields to fetch from the Comment
    **/
    select?: XOR<CommentSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<CommentInclude, null>
    /**
     * The data needed to update a Comment.
    **/
    data: CommentUpdateInput
    /**
     * Choose, which Comment to update.
    **/
    where: CommentWhereUniqueInput
  }


  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs = {
    data: CommentUpdateManyMutationInput
    where?: CommentWhereInput
  }


  /**
   * Comment upsert
   */
  export type CommentUpsertArgs = {
    /**
     * Select specific fields to fetch from the Comment
    **/
    select?: XOR<CommentSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<CommentInclude, null>
    /**
     * The filter to search for the Comment to update in case it exists.
    **/
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
    **/
    create: CommentCreateInput
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
    **/
    update: CommentUpdateInput
  }


  /**
   * Comment delete
   */
  export type CommentDeleteArgs = {
    /**
     * Select specific fields to fetch from the Comment
    **/
    select?: XOR<CommentSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<CommentInclude, null>
    /**
     * Filter which Comment to delete.
    **/
    where: CommentWhereUniqueInput
  }


  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs = {
    where?: CommentWhereInput
  }


  /**
   * Comment without action
   */
  export type CommentArgs = {
    /**
     * Select specific fields to fetch from the Comment
    **/
    select?: XOR<CommentSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<CommentInclude, null>
  }



  /**
   * Model Subscription
   */


  export type AggregateSubscription = {
    count: number
  }



  export type AggregateSubscriptionArgs = {
    where?: SubscriptionWhereInput
    orderBy?: XOR<Enumerable<SubscriptionOrderByInput>, SubscriptionOrderByInput>
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SubscriptionDistinctFieldEnum>
    count?: true
  }

  export type GetSubscriptionAggregateType<T extends AggregateSubscriptionArgs> = {
    [P in keyof T]: P extends 'count' ? number : never
  }


    
    

  export type SubscriptionSelect = {
    id?: boolean
    createdAt?: boolean
    subscriberId?: boolean
    subscribedToId?: boolean
    subscriber?: boolean | UserArgs
    subscribedTo?: boolean | UserArgs
  }

  export type SubscriptionInclude = {
    subscriber?: boolean | UserArgs
    subscribedTo?: boolean | UserArgs
  }

  export type SubscriptionGetPayload<
    S extends boolean | null | undefined | SubscriptionArgs,
    U = keyof S
      > = S extends true
        ? Subscription
    : S extends undefined
    ? never
    : S extends SubscriptionArgs | FindManySubscriptionArgs
    ?'include' extends U
    ? Subscription  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'subscriber'
        ? UserGetPayload<S['include'][P]> :
        P extends 'subscribedTo'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Subscription ?Subscription [P]
  : 
          P extends 'subscriber'
        ? UserGetPayload<S['select'][P]> :
        P extends 'subscribedTo'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : Subscription
  : Subscription


  export interface SubscriptionDelegate {
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {FindUniqueSubscriptionArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueSubscriptionArgs>(
      args: Subset<T, FindUniqueSubscriptionArgs>
    ): CheckSelect<T, Prisma__SubscriptionClient<Subscription | null>, Prisma__SubscriptionClient<SubscriptionGetPayload<T> | null>>
    /**
     * Find the first Subscription that matches the filter.
     * @param {FindFirstSubscriptionArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstSubscriptionArgs>(
      args?: Subset<T, FindFirstSubscriptionArgs>
    ): CheckSelect<T, Prisma__SubscriptionClient<Subscription | null>, Prisma__SubscriptionClient<SubscriptionGetPayload<T> | null>>
    /**
     * Find zero or more Subscriptions that matches the filter.
     * @param {FindManySubscriptionArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManySubscriptionArgs>(
      args?: Subset<T, FindManySubscriptionArgs>
    ): CheckSelect<T, Promise<Array<Subscription>>, Promise<Array<SubscriptionGetPayload<T>>>>
    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
    **/
    create<T extends SubscriptionCreateArgs>(
      args: Subset<T, SubscriptionCreateArgs>
    ): CheckSelect<T, Prisma__SubscriptionClient<Subscription>, Prisma__SubscriptionClient<SubscriptionGetPayload<T>>>
    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
    **/
    delete<T extends SubscriptionDeleteArgs>(
      args: Subset<T, SubscriptionDeleteArgs>
    ): CheckSelect<T, Prisma__SubscriptionClient<Subscription>, Prisma__SubscriptionClient<SubscriptionGetPayload<T>>>
    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubscriptionUpdateArgs>(
      args: Subset<T, SubscriptionUpdateArgs>
    ): CheckSelect<T, Prisma__SubscriptionClient<Subscription>, Prisma__SubscriptionClient<SubscriptionGetPayload<T>>>
    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubscriptionDeleteManyArgs>(
      args: Subset<T, SubscriptionDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more Subscriptions.
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubscriptionUpdateManyArgs>(
      args: Subset<T, SubscriptionUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
    **/
    upsert<T extends SubscriptionUpsertArgs>(
      args: Subset<T, SubscriptionUpsertArgs>
    ): CheckSelect<T, Prisma__SubscriptionClient<Subscription>, Prisma__SubscriptionClient<SubscriptionGetPayload<T>>>
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {FindUniqueSubscriptionArgs} args - Arguments to find a Subscription
     * @deprecated This will be deprecated please use prisma.subscription.findUnique
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueSubscriptionArgs>(
      args: Subset<T, FindUniqueSubscriptionArgs>
    ): CheckSelect<T, Prisma__SubscriptionClient<Subscription | null>, Prisma__SubscriptionClient<SubscriptionGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManySubscriptionArgs, 'select' | 'include'>): Promise<number>

    /**
     * Aggregate
     */
    aggregate<T extends AggregateSubscriptionArgs>(args: Subset<T, AggregateSubscriptionArgs>): Promise<GetSubscriptionAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SubscriptionClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    subscriber<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null>, Prisma__UserClient<UserGetPayload<T> | null>>;

    subscribedTo<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null>, Prisma__UserClient<UserGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Subscription findUnique
   */
  export type FindUniqueSubscriptionArgs = {
    /**
     * Select specific fields to fetch from the Subscription
    **/
    select?: XOR<SubscriptionSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<SubscriptionInclude, null>
    /**
     * Filter, which Subscription to fetch.
    **/
    where: SubscriptionWhereUniqueInput
  }


  /**
   * Subscription findFirst
   */
  export type FindFirstSubscriptionArgs = {
    /**
     * Select specific fields to fetch from the Subscription
    **/
    select?: XOR<SubscriptionSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<SubscriptionInclude, null>
    /**
     * Filter, which Subscription to fetch.
    **/
    where?: SubscriptionWhereInput
    orderBy?: XOR<Enumerable<SubscriptionOrderByInput>, SubscriptionOrderByInput>
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SubscriptionDistinctFieldEnum>
  }


  /**
   * Subscription findMany
   */
  export type FindManySubscriptionArgs = {
    /**
     * Select specific fields to fetch from the Subscription
    **/
    select?: XOR<SubscriptionSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<SubscriptionInclude, null>
    /**
     * Filter, which Subscriptions to fetch.
    **/
    where?: SubscriptionWhereInput
    /**
     * Determine the order of the Subscriptions to fetch.
    **/
    orderBy?: XOR<Enumerable<SubscriptionOrderByInput>, SubscriptionOrderByInput>
    /**
     * Sets the position for listing Subscriptions.
    **/
    cursor?: SubscriptionWhereUniqueInput
    /**
     * The number of Subscriptions to fetch. If negative number, it will take Subscriptions before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` Subscriptions.
    **/
    skip?: number
    distinct?: Enumerable<SubscriptionDistinctFieldEnum>
  }


  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs = {
    /**
     * Select specific fields to fetch from the Subscription
    **/
    select?: XOR<SubscriptionSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<SubscriptionInclude, null>
    /**
     * The data needed to create a Subscription.
    **/
    data: SubscriptionCreateInput
  }


  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Subscription
    **/
    select?: XOR<SubscriptionSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<SubscriptionInclude, null>
    /**
     * The data needed to update a Subscription.
    **/
    data: SubscriptionUpdateInput
    /**
     * Choose, which Subscription to update.
    **/
    where: SubscriptionWhereUniqueInput
  }


  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs = {
    data: SubscriptionUpdateManyMutationInput
    where?: SubscriptionWhereInput
  }


  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Subscription
    **/
    select?: XOR<SubscriptionSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<SubscriptionInclude, null>
    /**
     * The filter to search for the Subscription to update in case it exists.
    **/
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
    **/
    create: SubscriptionCreateInput
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
    **/
    update: SubscriptionUpdateInput
  }


  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Subscription
    **/
    select?: XOR<SubscriptionSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<SubscriptionInclude, null>
    /**
     * Filter which Subscription to delete.
    **/
    where: SubscriptionWhereUniqueInput
  }


  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs = {
    where?: SubscriptionWhereInput
  }


  /**
   * Subscription without action
   */
  export type SubscriptionArgs = {
    /**
     * Select specific fields to fetch from the Subscription
    **/
    select?: XOR<SubscriptionSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<SubscriptionInclude, null>
  }



  /**
   * Model Video
   */


  export type AggregateVideo = {
    count: number
  }



  export type AggregateVideoArgs = {
    where?: VideoWhereInput
    orderBy?: XOR<Enumerable<VideoOrderByInput>, VideoOrderByInput>
    cursor?: VideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<VideoDistinctFieldEnum>
    count?: true
  }

  export type GetVideoAggregateType<T extends AggregateVideoArgs> = {
    [P in keyof T]: P extends 'count' ? number : never
  }


    
    

  export type VideoSelect = {
    id?: boolean
    createdAt?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    thumbnail?: boolean
    userId?: boolean
    user?: boolean | UserArgs
    videoLikes?: boolean | FindManyVideoLikeArgs
    comments?: boolean | FindManyCommentArgs
    views?: boolean | FindManyViewArgs
  }

  export type VideoInclude = {
    user?: boolean | UserArgs
    videoLikes?: boolean | FindManyVideoLikeArgs
    comments?: boolean | FindManyCommentArgs
    views?: boolean | FindManyViewArgs
  }

  export type VideoGetPayload<
    S extends boolean | null | undefined | VideoArgs,
    U = keyof S
      > = S extends true
        ? Video
    : S extends undefined
    ? never
    : S extends VideoArgs | FindManyVideoArgs
    ?'include' extends U
    ? Video  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> :
        P extends 'videoLikes'
        ? Array < VideoLikeGetPayload<S['include'][P]>>  :
        P extends 'comments'
        ? Array < CommentGetPayload<S['include'][P]>>  :
        P extends 'views'
        ? Array < ViewGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Video ?Video [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> :
        P extends 'videoLikes'
        ? Array < VideoLikeGetPayload<S['select'][P]>>  :
        P extends 'comments'
        ? Array < CommentGetPayload<S['select'][P]>>  :
        P extends 'views'
        ? Array < ViewGetPayload<S['select'][P]>>  : never
  } 
    : Video
  : Video


  export interface VideoDelegate {
    /**
     * Find zero or one Video that matches the filter.
     * @param {FindUniqueVideoArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueVideoArgs>(
      args: Subset<T, FindUniqueVideoArgs>
    ): CheckSelect<T, Prisma__VideoClient<Video | null>, Prisma__VideoClient<VideoGetPayload<T> | null>>
    /**
     * Find the first Video that matches the filter.
     * @param {FindFirstVideoArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstVideoArgs>(
      args?: Subset<T, FindFirstVideoArgs>
    ): CheckSelect<T, Prisma__VideoClient<Video | null>, Prisma__VideoClient<VideoGetPayload<T> | null>>
    /**
     * Find zero or more Videos that matches the filter.
     * @param {FindManyVideoArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Videos
     * const videos = await prisma.video.findMany()
     * 
     * // Get first 10 Videos
     * const videos = await prisma.video.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoWithIdOnly = await prisma.video.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManyVideoArgs>(
      args?: Subset<T, FindManyVideoArgs>
    ): CheckSelect<T, Promise<Array<Video>>, Promise<Array<VideoGetPayload<T>>>>
    /**
     * Create a Video.
     * @param {VideoCreateArgs} args - Arguments to create a Video.
     * @example
     * // Create one Video
     * const Video = await prisma.video.create({
     *   data: {
     *     // ... data to create a Video
     *   }
     * })
     * 
    **/
    create<T extends VideoCreateArgs>(
      args: Subset<T, VideoCreateArgs>
    ): CheckSelect<T, Prisma__VideoClient<Video>, Prisma__VideoClient<VideoGetPayload<T>>>
    /**
     * Delete a Video.
     * @param {VideoDeleteArgs} args - Arguments to delete one Video.
     * @example
     * // Delete one Video
     * const Video = await prisma.video.delete({
     *   where: {
     *     // ... filter to delete one Video
     *   }
     * })
     * 
    **/
    delete<T extends VideoDeleteArgs>(
      args: Subset<T, VideoDeleteArgs>
    ): CheckSelect<T, Prisma__VideoClient<Video>, Prisma__VideoClient<VideoGetPayload<T>>>
    /**
     * Update one Video.
     * @param {VideoUpdateArgs} args - Arguments to update one Video.
     * @example
     * // Update one Video
     * const video = await prisma.video.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VideoUpdateArgs>(
      args: Subset<T, VideoUpdateArgs>
    ): CheckSelect<T, Prisma__VideoClient<Video>, Prisma__VideoClient<VideoGetPayload<T>>>
    /**
     * Delete zero or more Videos.
     * @param {VideoDeleteManyArgs} args - Arguments to filter Videos to delete.
     * @example
     * // Delete a few Videos
     * const { count } = await prisma.video.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VideoDeleteManyArgs>(
      args: Subset<T, VideoDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more Videos.
     * @param {VideoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Videos
     * const video = await prisma.video.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VideoUpdateManyArgs>(
      args: Subset<T, VideoUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one Video.
     * @param {VideoUpsertArgs} args - Arguments to update or create a Video.
     * @example
     * // Update or create a Video
     * const video = await prisma.video.upsert({
     *   create: {
     *     // ... data to create a Video
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Video we want to update
     *   }
     * })
    **/
    upsert<T extends VideoUpsertArgs>(
      args: Subset<T, VideoUpsertArgs>
    ): CheckSelect<T, Prisma__VideoClient<Video>, Prisma__VideoClient<VideoGetPayload<T>>>
    /**
     * Find zero or one Video that matches the filter.
     * @param {FindUniqueVideoArgs} args - Arguments to find a Video
     * @deprecated This will be deprecated please use prisma.video.findUnique
     * @example
     * // Get one Video
     * const video = await prisma.video.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueVideoArgs>(
      args: Subset<T, FindUniqueVideoArgs>
    ): CheckSelect<T, Prisma__VideoClient<Video | null>, Prisma__VideoClient<VideoGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManyVideoArgs, 'select' | 'include'>): Promise<number>

    /**
     * Aggregate
     */
    aggregate<T extends AggregateVideoArgs>(args: Subset<T, AggregateVideoArgs>): Promise<GetVideoAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Video.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VideoClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null>, Prisma__UserClient<UserGetPayload<T> | null>>;

    videoLikes<T extends FindManyVideoLikeArgs = {}>(args?: Subset<T, FindManyVideoLikeArgs>): CheckSelect<T, Promise<Array<VideoLike>>, Promise<Array<VideoLikeGetPayload<T>>>>;

    comments<T extends FindManyCommentArgs = {}>(args?: Subset<T, FindManyCommentArgs>): CheckSelect<T, Promise<Array<Comment>>, Promise<Array<CommentGetPayload<T>>>>;

    views<T extends FindManyViewArgs = {}>(args?: Subset<T, FindManyViewArgs>): CheckSelect<T, Promise<Array<View>>, Promise<Array<ViewGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Video findUnique
   */
  export type FindUniqueVideoArgs = {
    /**
     * Select specific fields to fetch from the Video
    **/
    select?: XOR<VideoSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<VideoInclude, null>
    /**
     * Filter, which Video to fetch.
    **/
    where: VideoWhereUniqueInput
  }


  /**
   * Video findFirst
   */
  export type FindFirstVideoArgs = {
    /**
     * Select specific fields to fetch from the Video
    **/
    select?: XOR<VideoSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<VideoInclude, null>
    /**
     * Filter, which Video to fetch.
    **/
    where?: VideoWhereInput
    orderBy?: XOR<Enumerable<VideoOrderByInput>, VideoOrderByInput>
    cursor?: VideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<VideoDistinctFieldEnum>
  }


  /**
   * Video findMany
   */
  export type FindManyVideoArgs = {
    /**
     * Select specific fields to fetch from the Video
    **/
    select?: XOR<VideoSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<VideoInclude, null>
    /**
     * Filter, which Videos to fetch.
    **/
    where?: VideoWhereInput
    /**
     * Determine the order of the Videos to fetch.
    **/
    orderBy?: XOR<Enumerable<VideoOrderByInput>, VideoOrderByInput>
    /**
     * Sets the position for listing Videos.
    **/
    cursor?: VideoWhereUniqueInput
    /**
     * The number of Videos to fetch. If negative number, it will take Videos before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` Videos.
    **/
    skip?: number
    distinct?: Enumerable<VideoDistinctFieldEnum>
  }


  /**
   * Video create
   */
  export type VideoCreateArgs = {
    /**
     * Select specific fields to fetch from the Video
    **/
    select?: XOR<VideoSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<VideoInclude, null>
    /**
     * The data needed to create a Video.
    **/
    data: VideoCreateInput
  }


  /**
   * Video update
   */
  export type VideoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Video
    **/
    select?: XOR<VideoSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<VideoInclude, null>
    /**
     * The data needed to update a Video.
    **/
    data: VideoUpdateInput
    /**
     * Choose, which Video to update.
    **/
    where: VideoWhereUniqueInput
  }


  /**
   * Video updateMany
   */
  export type VideoUpdateManyArgs = {
    data: VideoUpdateManyMutationInput
    where?: VideoWhereInput
  }


  /**
   * Video upsert
   */
  export type VideoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Video
    **/
    select?: XOR<VideoSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<VideoInclude, null>
    /**
     * The filter to search for the Video to update in case it exists.
    **/
    where: VideoWhereUniqueInput
    /**
     * In case the Video found by the `where` argument doesn't exist, create a new Video with this data.
    **/
    create: VideoCreateInput
    /**
     * In case the Video was found with the provided `where` argument, update it with this data.
    **/
    update: VideoUpdateInput
  }


  /**
   * Video delete
   */
  export type VideoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Video
    **/
    select?: XOR<VideoSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<VideoInclude, null>
    /**
     * Filter which Video to delete.
    **/
    where: VideoWhereUniqueInput
  }


  /**
   * Video deleteMany
   */
  export type VideoDeleteManyArgs = {
    where?: VideoWhereInput
  }


  /**
   * Video without action
   */
  export type VideoArgs = {
    /**
     * Select specific fields to fetch from the Video
    **/
    select?: XOR<VideoSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<VideoInclude, null>
  }



  /**
   * Model VideoLike
   */


  export type AggregateVideoLike = {
    count: number
    avg: VideoLikeAvgAggregateOutputType | null
    sum: VideoLikeSumAggregateOutputType | null
    min: VideoLikeMinAggregateOutputType | null
    max: VideoLikeMaxAggregateOutputType | null
  }

  export type VideoLikeAvgAggregateOutputType = {
    like: number
  }

  export type VideoLikeSumAggregateOutputType = {
    like: number
  }

  export type VideoLikeMinAggregateOutputType = {
    like: number
  }

  export type VideoLikeMaxAggregateOutputType = {
    like: number
  }


  export type VideoLikeAvgAggregateInputType = {
    like?: true
  }

  export type VideoLikeSumAggregateInputType = {
    like?: true
  }

  export type VideoLikeMinAggregateInputType = {
    like?: true
  }

  export type VideoLikeMaxAggregateInputType = {
    like?: true
  }

  export type AggregateVideoLikeArgs = {
    where?: VideoLikeWhereInput
    orderBy?: XOR<Enumerable<VideoLikeOrderByInput>, VideoLikeOrderByInput>
    cursor?: VideoLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<VideoLikeDistinctFieldEnum>
    count?: true
    avg?: VideoLikeAvgAggregateInputType
    sum?: VideoLikeSumAggregateInputType
    min?: VideoLikeMinAggregateInputType
    max?: VideoLikeMaxAggregateInputType
  }

  export type GetVideoLikeAggregateType<T extends AggregateVideoLikeArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetVideoLikeAggregateScalarType<T[P]>
  }

  export type GetVideoLikeAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof VideoLikeAvgAggregateOutputType ? VideoLikeAvgAggregateOutputType[P] : never
  }
    
    

  export type VideoLikeSelect = {
    id?: boolean
    createdAt?: boolean
    like?: boolean
    userId?: boolean
    videoId?: boolean
    user?: boolean | UserArgs
    video?: boolean | VideoArgs
  }

  export type VideoLikeInclude = {
    user?: boolean | UserArgs
    video?: boolean | VideoArgs
  }

  export type VideoLikeGetPayload<
    S extends boolean | null | undefined | VideoLikeArgs,
    U = keyof S
      > = S extends true
        ? VideoLike
    : S extends undefined
    ? never
    : S extends VideoLikeArgs | FindManyVideoLikeArgs
    ?'include' extends U
    ? VideoLike  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> :
        P extends 'video'
        ? VideoGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof VideoLike ?VideoLike [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> :
        P extends 'video'
        ? VideoGetPayload<S['select'][P]> : never
  } 
    : VideoLike
  : VideoLike


  export interface VideoLikeDelegate {
    /**
     * Find zero or one VideoLike that matches the filter.
     * @param {FindUniqueVideoLikeArgs} args - Arguments to find a VideoLike
     * @example
     * // Get one VideoLike
     * const videoLike = await prisma.videoLike.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueVideoLikeArgs>(
      args: Subset<T, FindUniqueVideoLikeArgs>
    ): CheckSelect<T, Prisma__VideoLikeClient<VideoLike | null>, Prisma__VideoLikeClient<VideoLikeGetPayload<T> | null>>
    /**
     * Find the first VideoLike that matches the filter.
     * @param {FindFirstVideoLikeArgs} args - Arguments to find a VideoLike
     * @example
     * // Get one VideoLike
     * const videoLike = await prisma.videoLike.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstVideoLikeArgs>(
      args?: Subset<T, FindFirstVideoLikeArgs>
    ): CheckSelect<T, Prisma__VideoLikeClient<VideoLike | null>, Prisma__VideoLikeClient<VideoLikeGetPayload<T> | null>>
    /**
     * Find zero or more VideoLikes that matches the filter.
     * @param {FindManyVideoLikeArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VideoLikes
     * const videoLikes = await prisma.videoLike.findMany()
     * 
     * // Get first 10 VideoLikes
     * const videoLikes = await prisma.videoLike.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoLikeWithIdOnly = await prisma.videoLike.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManyVideoLikeArgs>(
      args?: Subset<T, FindManyVideoLikeArgs>
    ): CheckSelect<T, Promise<Array<VideoLike>>, Promise<Array<VideoLikeGetPayload<T>>>>
    /**
     * Create a VideoLike.
     * @param {VideoLikeCreateArgs} args - Arguments to create a VideoLike.
     * @example
     * // Create one VideoLike
     * const VideoLike = await prisma.videoLike.create({
     *   data: {
     *     // ... data to create a VideoLike
     *   }
     * })
     * 
    **/
    create<T extends VideoLikeCreateArgs>(
      args: Subset<T, VideoLikeCreateArgs>
    ): CheckSelect<T, Prisma__VideoLikeClient<VideoLike>, Prisma__VideoLikeClient<VideoLikeGetPayload<T>>>
    /**
     * Delete a VideoLike.
     * @param {VideoLikeDeleteArgs} args - Arguments to delete one VideoLike.
     * @example
     * // Delete one VideoLike
     * const VideoLike = await prisma.videoLike.delete({
     *   where: {
     *     // ... filter to delete one VideoLike
     *   }
     * })
     * 
    **/
    delete<T extends VideoLikeDeleteArgs>(
      args: Subset<T, VideoLikeDeleteArgs>
    ): CheckSelect<T, Prisma__VideoLikeClient<VideoLike>, Prisma__VideoLikeClient<VideoLikeGetPayload<T>>>
    /**
     * Update one VideoLike.
     * @param {VideoLikeUpdateArgs} args - Arguments to update one VideoLike.
     * @example
     * // Update one VideoLike
     * const videoLike = await prisma.videoLike.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VideoLikeUpdateArgs>(
      args: Subset<T, VideoLikeUpdateArgs>
    ): CheckSelect<T, Prisma__VideoLikeClient<VideoLike>, Prisma__VideoLikeClient<VideoLikeGetPayload<T>>>
    /**
     * Delete zero or more VideoLikes.
     * @param {VideoLikeDeleteManyArgs} args - Arguments to filter VideoLikes to delete.
     * @example
     * // Delete a few VideoLikes
     * const { count } = await prisma.videoLike.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VideoLikeDeleteManyArgs>(
      args: Subset<T, VideoLikeDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more VideoLikes.
     * @param {VideoLikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VideoLikes
     * const videoLike = await prisma.videoLike.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VideoLikeUpdateManyArgs>(
      args: Subset<T, VideoLikeUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one VideoLike.
     * @param {VideoLikeUpsertArgs} args - Arguments to update or create a VideoLike.
     * @example
     * // Update or create a VideoLike
     * const videoLike = await prisma.videoLike.upsert({
     *   create: {
     *     // ... data to create a VideoLike
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VideoLike we want to update
     *   }
     * })
    **/
    upsert<T extends VideoLikeUpsertArgs>(
      args: Subset<T, VideoLikeUpsertArgs>
    ): CheckSelect<T, Prisma__VideoLikeClient<VideoLike>, Prisma__VideoLikeClient<VideoLikeGetPayload<T>>>
    /**
     * Find zero or one VideoLike that matches the filter.
     * @param {FindUniqueVideoLikeArgs} args - Arguments to find a VideoLike
     * @deprecated This will be deprecated please use prisma.videoLike.findUnique
     * @example
     * // Get one VideoLike
     * const videoLike = await prisma.videoLike.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueVideoLikeArgs>(
      args: Subset<T, FindUniqueVideoLikeArgs>
    ): CheckSelect<T, Prisma__VideoLikeClient<VideoLike | null>, Prisma__VideoLikeClient<VideoLikeGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManyVideoLikeArgs, 'select' | 'include'>): Promise<number>

    /**
     * Aggregate
     */
    aggregate<T extends AggregateVideoLikeArgs>(args: Subset<T, AggregateVideoLikeArgs>): Promise<GetVideoLikeAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for VideoLike.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VideoLikeClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null>, Prisma__UserClient<UserGetPayload<T> | null>>;

    video<T extends VideoArgs = {}>(args?: Subset<T, VideoArgs>): CheckSelect<T, Prisma__VideoClient<Video | null>, Prisma__VideoClient<VideoGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * VideoLike findUnique
   */
  export type FindUniqueVideoLikeArgs = {
    /**
     * Select specific fields to fetch from the VideoLike
    **/
    select?: XOR<VideoLikeSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<VideoLikeInclude, null>
    /**
     * Filter, which VideoLike to fetch.
    **/
    where: VideoLikeWhereUniqueInput
  }


  /**
   * VideoLike findFirst
   */
  export type FindFirstVideoLikeArgs = {
    /**
     * Select specific fields to fetch from the VideoLike
    **/
    select?: XOR<VideoLikeSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<VideoLikeInclude, null>
    /**
     * Filter, which VideoLike to fetch.
    **/
    where?: VideoLikeWhereInput
    orderBy?: XOR<Enumerable<VideoLikeOrderByInput>, VideoLikeOrderByInput>
    cursor?: VideoLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<VideoLikeDistinctFieldEnum>
  }


  /**
   * VideoLike findMany
   */
  export type FindManyVideoLikeArgs = {
    /**
     * Select specific fields to fetch from the VideoLike
    **/
    select?: XOR<VideoLikeSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<VideoLikeInclude, null>
    /**
     * Filter, which VideoLikes to fetch.
    **/
    where?: VideoLikeWhereInput
    /**
     * Determine the order of the VideoLikes to fetch.
    **/
    orderBy?: XOR<Enumerable<VideoLikeOrderByInput>, VideoLikeOrderByInput>
    /**
     * Sets the position for listing VideoLikes.
    **/
    cursor?: VideoLikeWhereUniqueInput
    /**
     * The number of VideoLikes to fetch. If negative number, it will take VideoLikes before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` VideoLikes.
    **/
    skip?: number
    distinct?: Enumerable<VideoLikeDistinctFieldEnum>
  }


  /**
   * VideoLike create
   */
  export type VideoLikeCreateArgs = {
    /**
     * Select specific fields to fetch from the VideoLike
    **/
    select?: XOR<VideoLikeSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<VideoLikeInclude, null>
    /**
     * The data needed to create a VideoLike.
    **/
    data: VideoLikeCreateInput
  }


  /**
   * VideoLike update
   */
  export type VideoLikeUpdateArgs = {
    /**
     * Select specific fields to fetch from the VideoLike
    **/
    select?: XOR<VideoLikeSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<VideoLikeInclude, null>
    /**
     * The data needed to update a VideoLike.
    **/
    data: VideoLikeUpdateInput
    /**
     * Choose, which VideoLike to update.
    **/
    where: VideoLikeWhereUniqueInput
  }


  /**
   * VideoLike updateMany
   */
  export type VideoLikeUpdateManyArgs = {
    data: VideoLikeUpdateManyMutationInput
    where?: VideoLikeWhereInput
  }


  /**
   * VideoLike upsert
   */
  export type VideoLikeUpsertArgs = {
    /**
     * Select specific fields to fetch from the VideoLike
    **/
    select?: XOR<VideoLikeSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<VideoLikeInclude, null>
    /**
     * The filter to search for the VideoLike to update in case it exists.
    **/
    where: VideoLikeWhereUniqueInput
    /**
     * In case the VideoLike found by the `where` argument doesn't exist, create a new VideoLike with this data.
    **/
    create: VideoLikeCreateInput
    /**
     * In case the VideoLike was found with the provided `where` argument, update it with this data.
    **/
    update: VideoLikeUpdateInput
  }


  /**
   * VideoLike delete
   */
  export type VideoLikeDeleteArgs = {
    /**
     * Select specific fields to fetch from the VideoLike
    **/
    select?: XOR<VideoLikeSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<VideoLikeInclude, null>
    /**
     * Filter which VideoLike to delete.
    **/
    where: VideoLikeWhereUniqueInput
  }


  /**
   * VideoLike deleteMany
   */
  export type VideoLikeDeleteManyArgs = {
    where?: VideoLikeWhereInput
  }


  /**
   * VideoLike without action
   */
  export type VideoLikeArgs = {
    /**
     * Select specific fields to fetch from the VideoLike
    **/
    select?: XOR<VideoLikeSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<VideoLikeInclude, null>
  }



  /**
   * Model View
   */


  export type AggregateView = {
    count: number
  }



  export type AggregateViewArgs = {
    where?: ViewWhereInput
    orderBy?: XOR<Enumerable<ViewOrderByInput>, ViewOrderByInput>
    cursor?: ViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ViewDistinctFieldEnum>
    count?: true
  }

  export type GetViewAggregateType<T extends AggregateViewArgs> = {
    [P in keyof T]: P extends 'count' ? number : never
  }


    
    

  export type ViewSelect = {
    id?: boolean
    createdAt?: boolean
    userId?: boolean
    videoId?: boolean
    user?: boolean | UserArgs
    video?: boolean | VideoArgs
  }

  export type ViewInclude = {
    user?: boolean | UserArgs
    video?: boolean | VideoArgs
  }

  export type ViewGetPayload<
    S extends boolean | null | undefined | ViewArgs,
    U = keyof S
      > = S extends true
        ? View
    : S extends undefined
    ? never
    : S extends ViewArgs | FindManyViewArgs
    ?'include' extends U
    ? View  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> | null :
        P extends 'video'
        ? VideoGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof View ?View [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> | null :
        P extends 'video'
        ? VideoGetPayload<S['select'][P]> : never
  } 
    : View
  : View


  export interface ViewDelegate {
    /**
     * Find zero or one View that matches the filter.
     * @param {FindUniqueViewArgs} args - Arguments to find a View
     * @example
     * // Get one View
     * const view = await prisma.view.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueViewArgs>(
      args: Subset<T, FindUniqueViewArgs>
    ): CheckSelect<T, Prisma__ViewClient<View | null>, Prisma__ViewClient<ViewGetPayload<T> | null>>
    /**
     * Find the first View that matches the filter.
     * @param {FindFirstViewArgs} args - Arguments to find a View
     * @example
     * // Get one View
     * const view = await prisma.view.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstViewArgs>(
      args?: Subset<T, FindFirstViewArgs>
    ): CheckSelect<T, Prisma__ViewClient<View | null>, Prisma__ViewClient<ViewGetPayload<T> | null>>
    /**
     * Find zero or more Views that matches the filter.
     * @param {FindManyViewArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Views
     * const views = await prisma.view.findMany()
     * 
     * // Get first 10 Views
     * const views = await prisma.view.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const viewWithIdOnly = await prisma.view.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManyViewArgs>(
      args?: Subset<T, FindManyViewArgs>
    ): CheckSelect<T, Promise<Array<View>>, Promise<Array<ViewGetPayload<T>>>>
    /**
     * Create a View.
     * @param {ViewCreateArgs} args - Arguments to create a View.
     * @example
     * // Create one View
     * const View = await prisma.view.create({
     *   data: {
     *     // ... data to create a View
     *   }
     * })
     * 
    **/
    create<T extends ViewCreateArgs>(
      args: Subset<T, ViewCreateArgs>
    ): CheckSelect<T, Prisma__ViewClient<View>, Prisma__ViewClient<ViewGetPayload<T>>>
    /**
     * Delete a View.
     * @param {ViewDeleteArgs} args - Arguments to delete one View.
     * @example
     * // Delete one View
     * const View = await prisma.view.delete({
     *   where: {
     *     // ... filter to delete one View
     *   }
     * })
     * 
    **/
    delete<T extends ViewDeleteArgs>(
      args: Subset<T, ViewDeleteArgs>
    ): CheckSelect<T, Prisma__ViewClient<View>, Prisma__ViewClient<ViewGetPayload<T>>>
    /**
     * Update one View.
     * @param {ViewUpdateArgs} args - Arguments to update one View.
     * @example
     * // Update one View
     * const view = await prisma.view.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ViewUpdateArgs>(
      args: Subset<T, ViewUpdateArgs>
    ): CheckSelect<T, Prisma__ViewClient<View>, Prisma__ViewClient<ViewGetPayload<T>>>
    /**
     * Delete zero or more Views.
     * @param {ViewDeleteManyArgs} args - Arguments to filter Views to delete.
     * @example
     * // Delete a few Views
     * const { count } = await prisma.view.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ViewDeleteManyArgs>(
      args: Subset<T, ViewDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more Views.
     * @param {ViewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Views
     * const view = await prisma.view.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ViewUpdateManyArgs>(
      args: Subset<T, ViewUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one View.
     * @param {ViewUpsertArgs} args - Arguments to update or create a View.
     * @example
     * // Update or create a View
     * const view = await prisma.view.upsert({
     *   create: {
     *     // ... data to create a View
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the View we want to update
     *   }
     * })
    **/
    upsert<T extends ViewUpsertArgs>(
      args: Subset<T, ViewUpsertArgs>
    ): CheckSelect<T, Prisma__ViewClient<View>, Prisma__ViewClient<ViewGetPayload<T>>>
    /**
     * Find zero or one View that matches the filter.
     * @param {FindUniqueViewArgs} args - Arguments to find a View
     * @deprecated This will be deprecated please use prisma.view.findUnique
     * @example
     * // Get one View
     * const view = await prisma.view.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueViewArgs>(
      args: Subset<T, FindUniqueViewArgs>
    ): CheckSelect<T, Prisma__ViewClient<View | null>, Prisma__ViewClient<ViewGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManyViewArgs, 'select' | 'include'>): Promise<number>

    /**
     * Aggregate
     */
    aggregate<T extends AggregateViewArgs>(args: Subset<T, AggregateViewArgs>): Promise<GetViewAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for View.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ViewClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null>, Prisma__UserClient<UserGetPayload<T> | null>>;

    video<T extends VideoArgs = {}>(args?: Subset<T, VideoArgs>): CheckSelect<T, Prisma__VideoClient<Video | null>, Prisma__VideoClient<VideoGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * View findUnique
   */
  export type FindUniqueViewArgs = {
    /**
     * Select specific fields to fetch from the View
    **/
    select?: XOR<ViewSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<ViewInclude, null>
    /**
     * Filter, which View to fetch.
    **/
    where: ViewWhereUniqueInput
  }


  /**
   * View findFirst
   */
  export type FindFirstViewArgs = {
    /**
     * Select specific fields to fetch from the View
    **/
    select?: XOR<ViewSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<ViewInclude, null>
    /**
     * Filter, which View to fetch.
    **/
    where?: ViewWhereInput
    orderBy?: XOR<Enumerable<ViewOrderByInput>, ViewOrderByInput>
    cursor?: ViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ViewDistinctFieldEnum>
  }


  /**
   * View findMany
   */
  export type FindManyViewArgs = {
    /**
     * Select specific fields to fetch from the View
    **/
    select?: XOR<ViewSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<ViewInclude, null>
    /**
     * Filter, which Views to fetch.
    **/
    where?: ViewWhereInput
    /**
     * Determine the order of the Views to fetch.
    **/
    orderBy?: XOR<Enumerable<ViewOrderByInput>, ViewOrderByInput>
    /**
     * Sets the position for listing Views.
    **/
    cursor?: ViewWhereUniqueInput
    /**
     * The number of Views to fetch. If negative number, it will take Views before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` Views.
    **/
    skip?: number
    distinct?: Enumerable<ViewDistinctFieldEnum>
  }


  /**
   * View create
   */
  export type ViewCreateArgs = {
    /**
     * Select specific fields to fetch from the View
    **/
    select?: XOR<ViewSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<ViewInclude, null>
    /**
     * The data needed to create a View.
    **/
    data: ViewCreateInput
  }


  /**
   * View update
   */
  export type ViewUpdateArgs = {
    /**
     * Select specific fields to fetch from the View
    **/
    select?: XOR<ViewSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<ViewInclude, null>
    /**
     * The data needed to update a View.
    **/
    data: ViewUpdateInput
    /**
     * Choose, which View to update.
    **/
    where: ViewWhereUniqueInput
  }


  /**
   * View updateMany
   */
  export type ViewUpdateManyArgs = {
    data: ViewUpdateManyMutationInput
    where?: ViewWhereInput
  }


  /**
   * View upsert
   */
  export type ViewUpsertArgs = {
    /**
     * Select specific fields to fetch from the View
    **/
    select?: XOR<ViewSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<ViewInclude, null>
    /**
     * The filter to search for the View to update in case it exists.
    **/
    where: ViewWhereUniqueInput
    /**
     * In case the View found by the `where` argument doesn't exist, create a new View with this data.
    **/
    create: ViewCreateInput
    /**
     * In case the View was found with the provided `where` argument, update it with this data.
    **/
    update: ViewUpdateInput
  }


  /**
   * View delete
   */
  export type ViewDeleteArgs = {
    /**
     * Select specific fields to fetch from the View
    **/
    select?: XOR<ViewSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<ViewInclude, null>
    /**
     * Filter which View to delete.
    **/
    where: ViewWhereUniqueInput
  }


  /**
   * View deleteMany
   */
  export type ViewDeleteManyArgs = {
    where?: ViewWhereInput
  }


  /**
   * View without action
   */
  export type ViewArgs = {
    /**
     * Select specific fields to fetch from the View
    **/
    select?: XOR<ViewSelect, null>
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: XOR<ViewInclude, null>
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const UserDistinctFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    username: 'username',
    email: 'email',
    avatar: 'avatar',
    cover: 'cover',
    about: 'about'
  };

  export type UserDistinctFieldEnum = (typeof UserDistinctFieldEnum)[keyof typeof UserDistinctFieldEnum]


  export const CommentDistinctFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    text: 'text',
    userId: 'userId',
    videoId: 'videoId'
  };

  export type CommentDistinctFieldEnum = (typeof CommentDistinctFieldEnum)[keyof typeof CommentDistinctFieldEnum]


  export const SubscriptionDistinctFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    subscriberId: 'subscriberId',
    subscribedToId: 'subscribedToId'
  };

  export type SubscriptionDistinctFieldEnum = (typeof SubscriptionDistinctFieldEnum)[keyof typeof SubscriptionDistinctFieldEnum]


  export const VideoDistinctFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    title: 'title',
    description: 'description',
    url: 'url',
    thumbnail: 'thumbnail',
    userId: 'userId'
  };

  export type VideoDistinctFieldEnum = (typeof VideoDistinctFieldEnum)[keyof typeof VideoDistinctFieldEnum]


  export const VideoLikeDistinctFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    like: 'like',
    userId: 'userId',
    videoId: 'videoId'
  };

  export type VideoLikeDistinctFieldEnum = (typeof VideoLikeDistinctFieldEnum)[keyof typeof VideoLikeDistinctFieldEnum]


  export const ViewDistinctFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    userId: 'userId',
    videoId: 'videoId'
  };

  export type ViewDistinctFieldEnum = (typeof ViewDistinctFieldEnum)[keyof typeof ViewDistinctFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: XOR<UserWhereInput, Enumerable<UserWhereInput>>
    OR?: XOR<UserWhereInput, Enumerable<UserWhereInput>>
    NOT?: XOR<UserWhereInput, Enumerable<UserWhereInput>>
    id?: XOR<StringFilter, string>
    createdAt?: XOR<DateTimeFilter, Date | string>
    username?: XOR<StringFilter, string>
    email?: XOR<StringFilter, string>
    avatar?: XOR<StringFilter, string>
    cover?: XOR<StringFilter, string>
    about?: XOR<StringFilter, string>
    videos?: VideoListRelationFilter
    videoLikes?: VideoLikeListRelationFilter
    comments?: CommentListRelationFilter
    subscribers?: SubscriptionListRelationFilter
    subscribedTo?: SubscriptionListRelationFilter
    views?: ViewListRelationFilter
  }

  export type UserOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    username?: SortOrder
    email?: SortOrder
    avatar?: SortOrder
    cover?: SortOrder
    about?: SortOrder
  }

  export type UserWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type CommentWhereInput = {
    AND?: XOR<CommentWhereInput, Enumerable<CommentWhereInput>>
    OR?: XOR<CommentWhereInput, Enumerable<CommentWhereInput>>
    NOT?: XOR<CommentWhereInput, Enumerable<CommentWhereInput>>
    id?: XOR<StringFilter, string>
    createdAt?: XOR<DateTimeFilter, Date | string>
    text?: XOR<StringFilter, string>
    userId?: XOR<StringFilter, string>
    videoId?: XOR<StringFilter, string>
    user?: XOR<UserRelationFilter, UserWhereInput>
    video?: XOR<VideoRelationFilter, VideoWhereInput>
  }

  export type CommentOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    text?: SortOrder
    userId?: SortOrder
    videoId?: SortOrder
  }

  export type CommentWhereUniqueInput = {
    id?: string
  }

  export type SubscriptionWhereInput = {
    AND?: XOR<SubscriptionWhereInput, Enumerable<SubscriptionWhereInput>>
    OR?: XOR<SubscriptionWhereInput, Enumerable<SubscriptionWhereInput>>
    NOT?: XOR<SubscriptionWhereInput, Enumerable<SubscriptionWhereInput>>
    id?: XOR<StringFilter, string>
    createdAt?: XOR<DateTimeFilter, Date | string>
    subscriberId?: XOR<StringFilter, string>
    subscribedToId?: XOR<StringFilter, string>
    subscriber?: XOR<UserRelationFilter, UserWhereInput>
    subscribedTo?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SubscriptionOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    subscriberId?: SortOrder
    subscribedToId?: SortOrder
  }

  export type SubscriptionWhereUniqueInput = {
    id?: string
  }

  export type VideoWhereInput = {
    AND?: XOR<VideoWhereInput, Enumerable<VideoWhereInput>>
    OR?: XOR<VideoWhereInput, Enumerable<VideoWhereInput>>
    NOT?: XOR<VideoWhereInput, Enumerable<VideoWhereInput>>
    id?: XOR<StringFilter, string>
    createdAt?: XOR<DateTimeFilter, Date | string>
    title?: XOR<StringFilter, string>
    description?: StringNullableFilter | string | null
    url?: XOR<StringFilter, string>
    thumbnail?: XOR<StringFilter, string>
    userId?: XOR<StringFilter, string>
    user?: XOR<UserRelationFilter, UserWhereInput>
    videoLikes?: VideoLikeListRelationFilter
    comments?: CommentListRelationFilter
    views?: ViewListRelationFilter
  }

  export type VideoOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    thumbnail?: SortOrder
    userId?: SortOrder
  }

  export type VideoWhereUniqueInput = {
    id?: string
  }

  export type VideoLikeWhereInput = {
    AND?: XOR<VideoLikeWhereInput, Enumerable<VideoLikeWhereInput>>
    OR?: XOR<VideoLikeWhereInput, Enumerable<VideoLikeWhereInput>>
    NOT?: XOR<VideoLikeWhereInput, Enumerable<VideoLikeWhereInput>>
    id?: XOR<StringFilter, string>
    createdAt?: XOR<DateTimeFilter, Date | string>
    like?: XOR<IntFilter, number>
    userId?: XOR<StringFilter, string>
    videoId?: XOR<StringFilter, string>
    user?: XOR<UserRelationFilter, UserWhereInput>
    video?: XOR<VideoRelationFilter, VideoWhereInput>
  }

  export type VideoLikeOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    like?: SortOrder
    userId?: SortOrder
    videoId?: SortOrder
  }

  export type VideoLikeWhereUniqueInput = {
    id?: string
  }

  export type ViewWhereInput = {
    AND?: XOR<ViewWhereInput, Enumerable<ViewWhereInput>>
    OR?: XOR<ViewWhereInput, Enumerable<ViewWhereInput>>
    NOT?: XOR<ViewWhereInput, Enumerable<ViewWhereInput>>
    id?: XOR<StringFilter, string>
    createdAt?: XOR<DateTimeFilter, Date | string>
    userId?: StringNullableFilter | string | null
    videoId?: XOR<StringFilter, string>
    user?: UserRelationFilter | UserWhereInput | null
    video?: XOR<VideoRelationFilter, VideoWhereInput>
  }

  export type ViewOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    videoId?: SortOrder
  }

  export type ViewWhereUniqueInput = {
    id?: string
  }

  export type UserCreateInput = {
    id?: string
    createdAt?: Date | string
    username: string
    email: string
    avatar?: string
    cover?: string
    about?: string
    videos?: VideoCreateManyWithoutUserInput
    videoLikes?: VideoLikeCreateManyWithoutUserInput
    comments?: CommentCreateManyWithoutUserInput
    subscribers?: SubscriptionCreateManyWithoutSubscriberInput
    subscribedTo?: SubscriptionCreateManyWithoutSubscribedToInput
    views?: ViewCreateManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: XOR<string, StringFieldUpdateOperationsInput>
    createdAt?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
    username?: XOR<string, StringFieldUpdateOperationsInput>
    email?: XOR<string, StringFieldUpdateOperationsInput>
    avatar?: XOR<string, StringFieldUpdateOperationsInput>
    cover?: XOR<string, StringFieldUpdateOperationsInput>
    about?: XOR<string, StringFieldUpdateOperationsInput>
    videos?: VideoUpdateManyWithoutUserInput
    videoLikes?: VideoLikeUpdateManyWithoutUserInput
    comments?: CommentUpdateManyWithoutUserInput
    subscribers?: SubscriptionUpdateManyWithoutSubscriberInput
    subscribedTo?: SubscriptionUpdateManyWithoutSubscribedToInput
    views?: ViewUpdateManyWithoutUserInput
  }

  export type UserUpdateManyMutationInput = {
    id?: XOR<string, StringFieldUpdateOperationsInput>
    createdAt?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
    username?: XOR<string, StringFieldUpdateOperationsInput>
    email?: XOR<string, StringFieldUpdateOperationsInput>
    avatar?: XOR<string, StringFieldUpdateOperationsInput>
    cover?: XOR<string, StringFieldUpdateOperationsInput>
    about?: XOR<string, StringFieldUpdateOperationsInput>
  }

  export type CommentCreateInput = {
    id?: string
    createdAt?: Date | string
    text: string
    user: UserCreateOneWithoutCommentsInput
    video: VideoCreateOneWithoutCommentsInput
  }

  export type CommentUpdateInput = {
    id?: XOR<string, StringFieldUpdateOperationsInput>
    createdAt?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
    text?: XOR<string, StringFieldUpdateOperationsInput>
    user?: UserUpdateOneRequiredWithoutCommentsInput
    video?: VideoUpdateOneRequiredWithoutCommentsInput
  }

  export type CommentUpdateManyMutationInput = {
    id?: XOR<string, StringFieldUpdateOperationsInput>
    createdAt?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
    text?: XOR<string, StringFieldUpdateOperationsInput>
  }

  export type SubscriptionCreateInput = {
    id?: string
    createdAt?: Date | string
    subscriber: UserCreateOneWithoutSubscribersInput
    subscribedTo: UserCreateOneWithoutSubscribedToInput
  }

  export type SubscriptionUpdateInput = {
    id?: XOR<string, StringFieldUpdateOperationsInput>
    createdAt?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
    subscriber?: UserUpdateOneRequiredWithoutSubscribersInput
    subscribedTo?: UserUpdateOneRequiredWithoutSubscribedToInput
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: XOR<string, StringFieldUpdateOperationsInput>
    createdAt?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
  }

  export type VideoCreateInput = {
    id?: string
    createdAt?: Date | string
    title: string
    description?: XOR<string, null>
    url: string
    thumbnail: string
    user: UserCreateOneWithoutVideosInput
    videoLikes?: VideoLikeCreateManyWithoutVideoInput
    comments?: CommentCreateManyWithoutVideoInput
    views?: ViewCreateManyWithoutVideoInput
  }

  export type VideoUpdateInput = {
    id?: XOR<string, StringFieldUpdateOperationsInput>
    createdAt?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
    title?: XOR<string, StringFieldUpdateOperationsInput>
    description?: string | NullableStringFieldUpdateOperationsInput | null
    url?: XOR<string, StringFieldUpdateOperationsInput>
    thumbnail?: XOR<string, StringFieldUpdateOperationsInput>
    user?: UserUpdateOneRequiredWithoutVideosInput
    videoLikes?: VideoLikeUpdateManyWithoutVideoInput
    comments?: CommentUpdateManyWithoutVideoInput
    views?: ViewUpdateManyWithoutVideoInput
  }

  export type VideoUpdateManyMutationInput = {
    id?: XOR<string, StringFieldUpdateOperationsInput>
    createdAt?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
    title?: XOR<string, StringFieldUpdateOperationsInput>
    description?: string | NullableStringFieldUpdateOperationsInput | null
    url?: XOR<string, StringFieldUpdateOperationsInput>
    thumbnail?: XOR<string, StringFieldUpdateOperationsInput>
  }

  export type VideoLikeCreateInput = {
    id?: string
    createdAt?: Date | string
    like?: number
    user: UserCreateOneWithoutVideoLikesInput
    video: VideoCreateOneWithoutVideoLikesInput
  }

  export type VideoLikeUpdateInput = {
    id?: XOR<string, StringFieldUpdateOperationsInput>
    createdAt?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
    like?: XOR<number, IntFieldUpdateOperationsInput>
    user?: UserUpdateOneRequiredWithoutVideoLikesInput
    video?: VideoUpdateOneRequiredWithoutVideoLikesInput
  }

  export type VideoLikeUpdateManyMutationInput = {
    id?: XOR<string, StringFieldUpdateOperationsInput>
    createdAt?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
    like?: XOR<number, IntFieldUpdateOperationsInput>
  }

  export type ViewCreateInput = {
    id?: string
    createdAt?: Date | string
    user?: UserCreateOneWithoutViewsInput
    video: VideoCreateOneWithoutViewsInput
  }

  export type ViewUpdateInput = {
    id?: XOR<string, StringFieldUpdateOperationsInput>
    createdAt?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
    user?: UserUpdateOneWithoutViewsInput
    video?: VideoUpdateOneRequiredWithoutViewsInput
  }

  export type ViewUpdateManyMutationInput = {
    id?: XOR<string, StringFieldUpdateOperationsInput>
    createdAt?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: XOR<string, NestedStringFilter>
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: XOR<Date | string, NestedDateTimeFilter>
  }

  export type VideoListRelationFilter = {
    every?: VideoWhereInput
    some?: VideoWhereInput
    none?: VideoWhereInput
  }

  export type VideoLikeListRelationFilter = {
    every?: VideoLikeWhereInput
    some?: VideoLikeWhereInput
    none?: VideoLikeWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type ViewListRelationFilter = {
    every?: ViewWhereInput
    some?: ViewWhereInput
    none?: ViewWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type VideoRelationFilter = {
    is?: VideoWhereInput
    isNot?: VideoWhereInput
  }

  export type StringNullableFilter = {
    equals?: XOR<string, null>
    in?: XOR<Enumerable<string>, null>
    notIn?: XOR<Enumerable<string>, null>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: string | NestedStringNullableFilter | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: XOR<number, NestedIntFilter>
  }

  export type VideoCreateManyWithoutUserInput = {
    create?: XOR<VideoCreateWithoutUserInput, Enumerable<VideoCreateWithoutUserInput>>
    connect?: XOR<VideoWhereUniqueInput, Enumerable<VideoWhereUniqueInput>>
    connectOrCreate?: XOR<VideoCreateOrConnectWithoutuserInput, Enumerable<VideoCreateOrConnectWithoutuserInput>>
  }

  export type VideoLikeCreateManyWithoutUserInput = {
    create?: XOR<VideoLikeCreateWithoutUserInput, Enumerable<VideoLikeCreateWithoutUserInput>>
    connect?: XOR<VideoLikeWhereUniqueInput, Enumerable<VideoLikeWhereUniqueInput>>
    connectOrCreate?: XOR<VideoLikeCreateOrConnectWithoutuserInput, Enumerable<VideoLikeCreateOrConnectWithoutuserInput>>
  }

  export type CommentCreateManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, Enumerable<CommentCreateWithoutUserInput>>
    connect?: XOR<CommentWhereUniqueInput, Enumerable<CommentWhereUniqueInput>>
    connectOrCreate?: XOR<CommentCreateOrConnectWithoutuserInput, Enumerable<CommentCreateOrConnectWithoutuserInput>>
  }

  export type SubscriptionCreateManyWithoutSubscriberInput = {
    create?: XOR<SubscriptionCreateWithoutSubscriberInput, Enumerable<SubscriptionCreateWithoutSubscriberInput>>
    connect?: XOR<SubscriptionWhereUniqueInput, Enumerable<SubscriptionWhereUniqueInput>>
    connectOrCreate?: XOR<SubscriptionCreateOrConnectWithoutsubscriberInput, Enumerable<SubscriptionCreateOrConnectWithoutsubscriberInput>>
  }

  export type SubscriptionCreateManyWithoutSubscribedToInput = {
    create?: XOR<SubscriptionCreateWithoutSubscribedToInput, Enumerable<SubscriptionCreateWithoutSubscribedToInput>>
    connect?: XOR<SubscriptionWhereUniqueInput, Enumerable<SubscriptionWhereUniqueInput>>
    connectOrCreate?: XOR<SubscriptionCreateOrConnectWithoutsubscribedToInput, Enumerable<SubscriptionCreateOrConnectWithoutsubscribedToInput>>
  }

  export type ViewCreateManyWithoutUserInput = {
    create?: XOR<ViewCreateWithoutUserInput, Enumerable<ViewCreateWithoutUserInput>>
    connect?: XOR<ViewWhereUniqueInput, Enumerable<ViewWhereUniqueInput>>
    connectOrCreate?: XOR<ViewCreateOrConnectWithoutuserInput, Enumerable<ViewCreateOrConnectWithoutuserInput>>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type VideoUpdateManyWithoutUserInput = {
    create?: XOR<VideoCreateWithoutUserInput, Enumerable<VideoCreateWithoutUserInput>>
    connect?: XOR<VideoWhereUniqueInput, Enumerable<VideoWhereUniqueInput>>
    set?: XOR<VideoWhereUniqueInput, Enumerable<VideoWhereUniqueInput>>
    disconnect?: XOR<VideoWhereUniqueInput, Enumerable<VideoWhereUniqueInput>>
    delete?: XOR<VideoWhereUniqueInput, Enumerable<VideoWhereUniqueInput>>
    update?: XOR<VideoUpdateWithWhereUniqueWithoutUserInput, Enumerable<VideoUpdateWithWhereUniqueWithoutUserInput>>
    updateMany?: XOR<VideoUpdateManyWithWhereWithoutUserInput, Enumerable<VideoUpdateManyWithWhereWithoutUserInput>>
    deleteMany?: XOR<VideoScalarWhereInput, Enumerable<VideoScalarWhereInput>>
    upsert?: XOR<VideoUpsertWithWhereUniqueWithoutUserInput, Enumerable<VideoUpsertWithWhereUniqueWithoutUserInput>>
    connectOrCreate?: XOR<VideoCreateOrConnectWithoutuserInput, Enumerable<VideoCreateOrConnectWithoutuserInput>>
  }

  export type VideoLikeUpdateManyWithoutUserInput = {
    create?: XOR<VideoLikeCreateWithoutUserInput, Enumerable<VideoLikeCreateWithoutUserInput>>
    connect?: XOR<VideoLikeWhereUniqueInput, Enumerable<VideoLikeWhereUniqueInput>>
    set?: XOR<VideoLikeWhereUniqueInput, Enumerable<VideoLikeWhereUniqueInput>>
    disconnect?: XOR<VideoLikeWhereUniqueInput, Enumerable<VideoLikeWhereUniqueInput>>
    delete?: XOR<VideoLikeWhereUniqueInput, Enumerable<VideoLikeWhereUniqueInput>>
    update?: XOR<VideoLikeUpdateWithWhereUniqueWithoutUserInput, Enumerable<VideoLikeUpdateWithWhereUniqueWithoutUserInput>>
    updateMany?: XOR<VideoLikeUpdateManyWithWhereWithoutUserInput, Enumerable<VideoLikeUpdateManyWithWhereWithoutUserInput>>
    deleteMany?: XOR<VideoLikeScalarWhereInput, Enumerable<VideoLikeScalarWhereInput>>
    upsert?: XOR<VideoLikeUpsertWithWhereUniqueWithoutUserInput, Enumerable<VideoLikeUpsertWithWhereUniqueWithoutUserInput>>
    connectOrCreate?: XOR<VideoLikeCreateOrConnectWithoutuserInput, Enumerable<VideoLikeCreateOrConnectWithoutuserInput>>
  }

  export type CommentUpdateManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, Enumerable<CommentCreateWithoutUserInput>>
    connect?: XOR<CommentWhereUniqueInput, Enumerable<CommentWhereUniqueInput>>
    set?: XOR<CommentWhereUniqueInput, Enumerable<CommentWhereUniqueInput>>
    disconnect?: XOR<CommentWhereUniqueInput, Enumerable<CommentWhereUniqueInput>>
    delete?: XOR<CommentWhereUniqueInput, Enumerable<CommentWhereUniqueInput>>
    update?: XOR<CommentUpdateWithWhereUniqueWithoutUserInput, Enumerable<CommentUpdateWithWhereUniqueWithoutUserInput>>
    updateMany?: XOR<CommentUpdateManyWithWhereWithoutUserInput, Enumerable<CommentUpdateManyWithWhereWithoutUserInput>>
    deleteMany?: XOR<CommentScalarWhereInput, Enumerable<CommentScalarWhereInput>>
    upsert?: XOR<CommentUpsertWithWhereUniqueWithoutUserInput, Enumerable<CommentUpsertWithWhereUniqueWithoutUserInput>>
    connectOrCreate?: XOR<CommentCreateOrConnectWithoutuserInput, Enumerable<CommentCreateOrConnectWithoutuserInput>>
  }

  export type SubscriptionUpdateManyWithoutSubscriberInput = {
    create?: XOR<SubscriptionCreateWithoutSubscriberInput, Enumerable<SubscriptionCreateWithoutSubscriberInput>>
    connect?: XOR<SubscriptionWhereUniqueInput, Enumerable<SubscriptionWhereUniqueInput>>
    set?: XOR<SubscriptionWhereUniqueInput, Enumerable<SubscriptionWhereUniqueInput>>
    disconnect?: XOR<SubscriptionWhereUniqueInput, Enumerable<SubscriptionWhereUniqueInput>>
    delete?: XOR<SubscriptionWhereUniqueInput, Enumerable<SubscriptionWhereUniqueInput>>
    update?: XOR<SubscriptionUpdateWithWhereUniqueWithoutSubscriberInput, Enumerable<SubscriptionUpdateWithWhereUniqueWithoutSubscriberInput>>
    updateMany?: XOR<SubscriptionUpdateManyWithWhereWithoutSubscriberInput, Enumerable<SubscriptionUpdateManyWithWhereWithoutSubscriberInput>>
    deleteMany?: XOR<SubscriptionScalarWhereInput, Enumerable<SubscriptionScalarWhereInput>>
    upsert?: XOR<SubscriptionUpsertWithWhereUniqueWithoutSubscriberInput, Enumerable<SubscriptionUpsertWithWhereUniqueWithoutSubscriberInput>>
    connectOrCreate?: XOR<SubscriptionCreateOrConnectWithoutsubscriberInput, Enumerable<SubscriptionCreateOrConnectWithoutsubscriberInput>>
  }

  export type SubscriptionUpdateManyWithoutSubscribedToInput = {
    create?: XOR<SubscriptionCreateWithoutSubscribedToInput, Enumerable<SubscriptionCreateWithoutSubscribedToInput>>
    connect?: XOR<SubscriptionWhereUniqueInput, Enumerable<SubscriptionWhereUniqueInput>>
    set?: XOR<SubscriptionWhereUniqueInput, Enumerable<SubscriptionWhereUniqueInput>>
    disconnect?: XOR<SubscriptionWhereUniqueInput, Enumerable<SubscriptionWhereUniqueInput>>
    delete?: XOR<SubscriptionWhereUniqueInput, Enumerable<SubscriptionWhereUniqueInput>>
    update?: XOR<SubscriptionUpdateWithWhereUniqueWithoutSubscribedToInput, Enumerable<SubscriptionUpdateWithWhereUniqueWithoutSubscribedToInput>>
    updateMany?: XOR<SubscriptionUpdateManyWithWhereWithoutSubscribedToInput, Enumerable<SubscriptionUpdateManyWithWhereWithoutSubscribedToInput>>
    deleteMany?: XOR<SubscriptionScalarWhereInput, Enumerable<SubscriptionScalarWhereInput>>
    upsert?: XOR<SubscriptionUpsertWithWhereUniqueWithoutSubscribedToInput, Enumerable<SubscriptionUpsertWithWhereUniqueWithoutSubscribedToInput>>
    connectOrCreate?: XOR<SubscriptionCreateOrConnectWithoutsubscribedToInput, Enumerable<SubscriptionCreateOrConnectWithoutsubscribedToInput>>
  }

  export type ViewUpdateManyWithoutUserInput = {
    create?: XOR<ViewCreateWithoutUserInput, Enumerable<ViewCreateWithoutUserInput>>
    connect?: XOR<ViewWhereUniqueInput, Enumerable<ViewWhereUniqueInput>>
    set?: XOR<ViewWhereUniqueInput, Enumerable<ViewWhereUniqueInput>>
    disconnect?: XOR<ViewWhereUniqueInput, Enumerable<ViewWhereUniqueInput>>
    delete?: XOR<ViewWhereUniqueInput, Enumerable<ViewWhereUniqueInput>>
    update?: XOR<ViewUpdateWithWhereUniqueWithoutUserInput, Enumerable<ViewUpdateWithWhereUniqueWithoutUserInput>>
    updateMany?: XOR<ViewUpdateManyWithWhereWithoutUserInput, Enumerable<ViewUpdateManyWithWhereWithoutUserInput>>
    deleteMany?: XOR<ViewScalarWhereInput, Enumerable<ViewScalarWhereInput>>
    upsert?: XOR<ViewUpsertWithWhereUniqueWithoutUserInput, Enumerable<ViewUpsertWithWhereUniqueWithoutUserInput>>
    connectOrCreate?: XOR<ViewCreateOrConnectWithoutuserInput, Enumerable<ViewCreateOrConnectWithoutuserInput>>
  }

  export type UserCreateOneWithoutCommentsInput = {
    create?: UserCreateWithoutCommentsInput
    connect?: UserWhereUniqueInput
    connectOrCreate?: UserCreateOrConnectWithoutcommentsInput
  }

  export type VideoCreateOneWithoutCommentsInput = {
    create?: VideoCreateWithoutCommentsInput
    connect?: VideoWhereUniqueInput
    connectOrCreate?: VideoCreateOrConnectWithoutcommentsInput
  }

  export type UserUpdateOneRequiredWithoutCommentsInput = {
    create?: UserCreateWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: UserUpdateWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connectOrCreate?: UserCreateOrConnectWithoutcommentsInput
  }

  export type VideoUpdateOneRequiredWithoutCommentsInput = {
    create?: VideoCreateWithoutCommentsInput
    connect?: VideoWhereUniqueInput
    update?: VideoUpdateWithoutCommentsInput
    upsert?: VideoUpsertWithoutCommentsInput
    connectOrCreate?: VideoCreateOrConnectWithoutcommentsInput
  }

  export type UserCreateOneWithoutSubscribersInput = {
    create?: UserCreateWithoutSubscribersInput
    connect?: UserWhereUniqueInput
    connectOrCreate?: UserCreateOrConnectWithoutsubscribersInput
  }

  export type UserCreateOneWithoutSubscribedToInput = {
    create?: UserCreateWithoutSubscribedToInput
    connect?: UserWhereUniqueInput
    connectOrCreate?: UserCreateOrConnectWithoutsubscribedToInput
  }

  export type UserUpdateOneRequiredWithoutSubscribersInput = {
    create?: UserCreateWithoutSubscribersInput
    connect?: UserWhereUniqueInput
    update?: UserUpdateWithoutSubscribersInput
    upsert?: UserUpsertWithoutSubscribersInput
    connectOrCreate?: UserCreateOrConnectWithoutsubscribersInput
  }

  export type UserUpdateOneRequiredWithoutSubscribedToInput = {
    create?: UserCreateWithoutSubscribedToInput
    connect?: UserWhereUniqueInput
    update?: UserUpdateWithoutSubscribedToInput
    upsert?: UserUpsertWithoutSubscribedToInput
    connectOrCreate?: UserCreateOrConnectWithoutsubscribedToInput
  }

  export type UserCreateOneWithoutVideosInput = {
    create?: UserCreateWithoutVideosInput
    connect?: UserWhereUniqueInput
    connectOrCreate?: UserCreateOrConnectWithoutvideosInput
  }

  export type VideoLikeCreateManyWithoutVideoInput = {
    create?: XOR<VideoLikeCreateWithoutVideoInput, Enumerable<VideoLikeCreateWithoutVideoInput>>
    connect?: XOR<VideoLikeWhereUniqueInput, Enumerable<VideoLikeWhereUniqueInput>>
    connectOrCreate?: XOR<VideoLikeCreateOrConnectWithoutvideoInput, Enumerable<VideoLikeCreateOrConnectWithoutvideoInput>>
  }

  export type CommentCreateManyWithoutVideoInput = {
    create?: XOR<CommentCreateWithoutVideoInput, Enumerable<CommentCreateWithoutVideoInput>>
    connect?: XOR<CommentWhereUniqueInput, Enumerable<CommentWhereUniqueInput>>
    connectOrCreate?: XOR<CommentCreateOrConnectWithoutvideoInput, Enumerable<CommentCreateOrConnectWithoutvideoInput>>
  }

  export type ViewCreateManyWithoutVideoInput = {
    create?: XOR<ViewCreateWithoutVideoInput, Enumerable<ViewCreateWithoutVideoInput>>
    connect?: XOR<ViewWhereUniqueInput, Enumerable<ViewWhereUniqueInput>>
    connectOrCreate?: XOR<ViewCreateOrConnectWithoutvideoInput, Enumerable<ViewCreateOrConnectWithoutvideoInput>>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: XOR<string, null>
  }

  export type UserUpdateOneRequiredWithoutVideosInput = {
    create?: UserCreateWithoutVideosInput
    connect?: UserWhereUniqueInput
    update?: UserUpdateWithoutVideosInput
    upsert?: UserUpsertWithoutVideosInput
    connectOrCreate?: UserCreateOrConnectWithoutvideosInput
  }

  export type VideoLikeUpdateManyWithoutVideoInput = {
    create?: XOR<VideoLikeCreateWithoutVideoInput, Enumerable<VideoLikeCreateWithoutVideoInput>>
    connect?: XOR<VideoLikeWhereUniqueInput, Enumerable<VideoLikeWhereUniqueInput>>
    set?: XOR<VideoLikeWhereUniqueInput, Enumerable<VideoLikeWhereUniqueInput>>
    disconnect?: XOR<VideoLikeWhereUniqueInput, Enumerable<VideoLikeWhereUniqueInput>>
    delete?: XOR<VideoLikeWhereUniqueInput, Enumerable<VideoLikeWhereUniqueInput>>
    update?: XOR<VideoLikeUpdateWithWhereUniqueWithoutVideoInput, Enumerable<VideoLikeUpdateWithWhereUniqueWithoutVideoInput>>
    updateMany?: XOR<VideoLikeUpdateManyWithWhereWithoutVideoInput, Enumerable<VideoLikeUpdateManyWithWhereWithoutVideoInput>>
    deleteMany?: XOR<VideoLikeScalarWhereInput, Enumerable<VideoLikeScalarWhereInput>>
    upsert?: XOR<VideoLikeUpsertWithWhereUniqueWithoutVideoInput, Enumerable<VideoLikeUpsertWithWhereUniqueWithoutVideoInput>>
    connectOrCreate?: XOR<VideoLikeCreateOrConnectWithoutvideoInput, Enumerable<VideoLikeCreateOrConnectWithoutvideoInput>>
  }

  export type CommentUpdateManyWithoutVideoInput = {
    create?: XOR<CommentCreateWithoutVideoInput, Enumerable<CommentCreateWithoutVideoInput>>
    connect?: XOR<CommentWhereUniqueInput, Enumerable<CommentWhereUniqueInput>>
    set?: XOR<CommentWhereUniqueInput, Enumerable<CommentWhereUniqueInput>>
    disconnect?: XOR<CommentWhereUniqueInput, Enumerable<CommentWhereUniqueInput>>
    delete?: XOR<CommentWhereUniqueInput, Enumerable<CommentWhereUniqueInput>>
    update?: XOR<CommentUpdateWithWhereUniqueWithoutVideoInput, Enumerable<CommentUpdateWithWhereUniqueWithoutVideoInput>>
    updateMany?: XOR<CommentUpdateManyWithWhereWithoutVideoInput, Enumerable<CommentUpdateManyWithWhereWithoutVideoInput>>
    deleteMany?: XOR<CommentScalarWhereInput, Enumerable<CommentScalarWhereInput>>
    upsert?: XOR<CommentUpsertWithWhereUniqueWithoutVideoInput, Enumerable<CommentUpsertWithWhereUniqueWithoutVideoInput>>
    connectOrCreate?: XOR<CommentCreateOrConnectWithoutvideoInput, Enumerable<CommentCreateOrConnectWithoutvideoInput>>
  }

  export type ViewUpdateManyWithoutVideoInput = {
    create?: XOR<ViewCreateWithoutVideoInput, Enumerable<ViewCreateWithoutVideoInput>>
    connect?: XOR<ViewWhereUniqueInput, Enumerable<ViewWhereUniqueInput>>
    set?: XOR<ViewWhereUniqueInput, Enumerable<ViewWhereUniqueInput>>
    disconnect?: XOR<ViewWhereUniqueInput, Enumerable<ViewWhereUniqueInput>>
    delete?: XOR<ViewWhereUniqueInput, Enumerable<ViewWhereUniqueInput>>
    update?: XOR<ViewUpdateWithWhereUniqueWithoutVideoInput, Enumerable<ViewUpdateWithWhereUniqueWithoutVideoInput>>
    updateMany?: XOR<ViewUpdateManyWithWhereWithoutVideoInput, Enumerable<ViewUpdateManyWithWhereWithoutVideoInput>>
    deleteMany?: XOR<ViewScalarWhereInput, Enumerable<ViewScalarWhereInput>>
    upsert?: XOR<ViewUpsertWithWhereUniqueWithoutVideoInput, Enumerable<ViewUpsertWithWhereUniqueWithoutVideoInput>>
    connectOrCreate?: XOR<ViewCreateOrConnectWithoutvideoInput, Enumerable<ViewCreateOrConnectWithoutvideoInput>>
  }

  export type UserCreateOneWithoutVideoLikesInput = {
    create?: UserCreateWithoutVideoLikesInput
    connect?: UserWhereUniqueInput
    connectOrCreate?: UserCreateOrConnectWithoutvideoLikesInput
  }

  export type VideoCreateOneWithoutVideoLikesInput = {
    create?: VideoCreateWithoutVideoLikesInput
    connect?: VideoWhereUniqueInput
    connectOrCreate?: VideoCreateOrConnectWithoutvideoLikesInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutVideoLikesInput = {
    create?: UserCreateWithoutVideoLikesInput
    connect?: UserWhereUniqueInput
    update?: UserUpdateWithoutVideoLikesInput
    upsert?: UserUpsertWithoutVideoLikesInput
    connectOrCreate?: UserCreateOrConnectWithoutvideoLikesInput
  }

  export type VideoUpdateOneRequiredWithoutVideoLikesInput = {
    create?: VideoCreateWithoutVideoLikesInput
    connect?: VideoWhereUniqueInput
    update?: VideoUpdateWithoutVideoLikesInput
    upsert?: VideoUpsertWithoutVideoLikesInput
    connectOrCreate?: VideoCreateOrConnectWithoutvideoLikesInput
  }

  export type UserCreateOneWithoutViewsInput = {
    create?: UserCreateWithoutViewsInput
    connect?: UserWhereUniqueInput
    connectOrCreate?: UserCreateOrConnectWithoutviewsInput
  }

  export type VideoCreateOneWithoutViewsInput = {
    create?: VideoCreateWithoutViewsInput
    connect?: VideoWhereUniqueInput
    connectOrCreate?: VideoCreateOrConnectWithoutviewsInput
  }

  export type UserUpdateOneWithoutViewsInput = {
    create?: UserCreateWithoutViewsInput
    connect?: UserWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: UserUpdateWithoutViewsInput
    upsert?: UserUpsertWithoutViewsInput
    connectOrCreate?: UserCreateOrConnectWithoutviewsInput
  }

  export type VideoUpdateOneRequiredWithoutViewsInput = {
    create?: VideoCreateWithoutViewsInput
    connect?: VideoWhereUniqueInput
    update?: VideoUpdateWithoutViewsInput
    upsert?: VideoUpsertWithoutViewsInput
    connectOrCreate?: VideoCreateOrConnectWithoutviewsInput
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: XOR<string, NestedStringFilter>
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: XOR<Date | string, NestedDateTimeFilter>
  }

  export type NestedStringNullableFilter = {
    equals?: XOR<string, null>
    in?: XOR<Enumerable<string>, null>
    notIn?: XOR<Enumerable<string>, null>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: string | NestedStringNullableFilter | null
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: XOR<number, NestedIntFilter>
  }

  export type VideoCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    title: string
    description?: XOR<string, null>
    url: string
    thumbnail: string
    videoLikes?: VideoLikeCreateManyWithoutVideoInput
    comments?: CommentCreateManyWithoutVideoInput
    views?: ViewCreateManyWithoutVideoInput
  }

  export type VideoCreateOrConnectWithoutuserInput = {
    where: VideoWhereUniqueInput
    create: VideoCreateWithoutUserInput
  }

  export type VideoLikeCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    like?: number
    video: VideoCreateOneWithoutVideoLikesInput
  }

  export type VideoLikeCreateOrConnectWithoutuserInput = {
    where: VideoLikeWhereUniqueInput
    create: VideoLikeCreateWithoutUserInput
  }

  export type CommentCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    text: string
    video: VideoCreateOneWithoutCommentsInput
  }

  export type CommentCreateOrConnectWithoutuserInput = {
    where: CommentWhereUniqueInput
    create: CommentCreateWithoutUserInput
  }

  export type SubscriptionCreateWithoutSubscriberInput = {
    id?: string
    createdAt?: Date | string
    subscribedTo: UserCreateOneWithoutSubscribedToInput
  }

  export type SubscriptionCreateOrConnectWithoutsubscriberInput = {
    where: SubscriptionWhereUniqueInput
    create: SubscriptionCreateWithoutSubscriberInput
  }

  export type SubscriptionCreateWithoutSubscribedToInput = {
    id?: string
    createdAt?: Date | string
    subscriber: UserCreateOneWithoutSubscribersInput
  }

  export type SubscriptionCreateOrConnectWithoutsubscribedToInput = {
    where: SubscriptionWhereUniqueInput
    create: SubscriptionCreateWithoutSubscribedToInput
  }

  export type ViewCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    video: VideoCreateOneWithoutViewsInput
  }

  export type ViewCreateOrConnectWithoutuserInput = {
    where: ViewWhereUniqueInput
    create: ViewCreateWithoutUserInput
  }

  export type VideoUpdateWithWhereUniqueWithoutUserInput = {
    where: VideoWhereUniqueInput
    data: VideoUpdateWithoutUserInput
  }

  export type VideoUpdateManyWithWhereWithoutUserInput = {
    where: VideoScalarWhereInput
    data: VideoUpdateManyMutationInput
  }

  export type VideoScalarWhereInput = {
    AND?: XOR<VideoScalarWhereInput, Enumerable<VideoScalarWhereInput>>
    OR?: XOR<VideoScalarWhereInput, Enumerable<VideoScalarWhereInput>>
    NOT?: XOR<VideoScalarWhereInput, Enumerable<VideoScalarWhereInput>>
    id?: XOR<StringFilter, string>
    createdAt?: XOR<DateTimeFilter, Date | string>
    title?: XOR<StringFilter, string>
    description?: StringNullableFilter | string | null
    url?: XOR<StringFilter, string>
    thumbnail?: XOR<StringFilter, string>
    userId?: XOR<StringFilter, string>
  }

  export type VideoUpsertWithWhereUniqueWithoutUserInput = {
    where: VideoWhereUniqueInput
    update: VideoUpdateWithoutUserInput
    create: VideoCreateWithoutUserInput
  }

  export type VideoLikeUpdateWithWhereUniqueWithoutUserInput = {
    where: VideoLikeWhereUniqueInput
    data: VideoLikeUpdateWithoutUserInput
  }

  export type VideoLikeUpdateManyWithWhereWithoutUserInput = {
    where: VideoLikeScalarWhereInput
    data: VideoLikeUpdateManyMutationInput
  }

  export type VideoLikeScalarWhereInput = {
    AND?: XOR<VideoLikeScalarWhereInput, Enumerable<VideoLikeScalarWhereInput>>
    OR?: XOR<VideoLikeScalarWhereInput, Enumerable<VideoLikeScalarWhereInput>>
    NOT?: XOR<VideoLikeScalarWhereInput, Enumerable<VideoLikeScalarWhereInput>>
    id?: XOR<StringFilter, string>
    createdAt?: XOR<DateTimeFilter, Date | string>
    like?: XOR<IntFilter, number>
    userId?: XOR<StringFilter, string>
    videoId?: XOR<StringFilter, string>
  }

  export type VideoLikeUpsertWithWhereUniqueWithoutUserInput = {
    where: VideoLikeWhereUniqueInput
    update: VideoLikeUpdateWithoutUserInput
    create: VideoLikeCreateWithoutUserInput
  }

  export type CommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    data: CommentUpdateWithoutUserInput
  }

  export type CommentUpdateManyWithWhereWithoutUserInput = {
    where: CommentScalarWhereInput
    data: CommentUpdateManyMutationInput
  }

  export type CommentScalarWhereInput = {
    AND?: XOR<CommentScalarWhereInput, Enumerable<CommentScalarWhereInput>>
    OR?: XOR<CommentScalarWhereInput, Enumerable<CommentScalarWhereInput>>
    NOT?: XOR<CommentScalarWhereInput, Enumerable<CommentScalarWhereInput>>
    id?: XOR<StringFilter, string>
    createdAt?: XOR<DateTimeFilter, Date | string>
    text?: XOR<StringFilter, string>
    userId?: XOR<StringFilter, string>
    videoId?: XOR<StringFilter, string>
  }

  export type CommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    update: CommentUpdateWithoutUserInput
    create: CommentCreateWithoutUserInput
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutSubscriberInput = {
    where: SubscriptionWhereUniqueInput
    data: SubscriptionUpdateWithoutSubscriberInput
  }

  export type SubscriptionUpdateManyWithWhereWithoutSubscriberInput = {
    where: SubscriptionScalarWhereInput
    data: SubscriptionUpdateManyMutationInput
  }

  export type SubscriptionScalarWhereInput = {
    AND?: XOR<SubscriptionScalarWhereInput, Enumerable<SubscriptionScalarWhereInput>>
    OR?: XOR<SubscriptionScalarWhereInput, Enumerable<SubscriptionScalarWhereInput>>
    NOT?: XOR<SubscriptionScalarWhereInput, Enumerable<SubscriptionScalarWhereInput>>
    id?: XOR<StringFilter, string>
    createdAt?: XOR<DateTimeFilter, Date | string>
    subscriberId?: XOR<StringFilter, string>
    subscribedToId?: XOR<StringFilter, string>
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutSubscriberInput = {
    where: SubscriptionWhereUniqueInput
    update: SubscriptionUpdateWithoutSubscriberInput
    create: SubscriptionCreateWithoutSubscriberInput
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutSubscribedToInput = {
    where: SubscriptionWhereUniqueInput
    data: SubscriptionUpdateWithoutSubscribedToInput
  }

  export type SubscriptionUpdateManyWithWhereWithoutSubscribedToInput = {
    where: SubscriptionScalarWhereInput
    data: SubscriptionUpdateManyMutationInput
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutSubscribedToInput = {
    where: SubscriptionWhereUniqueInput
    update: SubscriptionUpdateWithoutSubscribedToInput
    create: SubscriptionCreateWithoutSubscribedToInput
  }

  export type ViewUpdateWithWhereUniqueWithoutUserInput = {
    where: ViewWhereUniqueInput
    data: ViewUpdateWithoutUserInput
  }

  export type ViewUpdateManyWithWhereWithoutUserInput = {
    where: ViewScalarWhereInput
    data: ViewUpdateManyMutationInput
  }

  export type ViewScalarWhereInput = {
    AND?: XOR<ViewScalarWhereInput, Enumerable<ViewScalarWhereInput>>
    OR?: XOR<ViewScalarWhereInput, Enumerable<ViewScalarWhereInput>>
    NOT?: XOR<ViewScalarWhereInput, Enumerable<ViewScalarWhereInput>>
    id?: XOR<StringFilter, string>
    createdAt?: XOR<DateTimeFilter, Date | string>
    userId?: StringNullableFilter | string | null
    videoId?: XOR<StringFilter, string>
  }

  export type ViewUpsertWithWhereUniqueWithoutUserInput = {
    where: ViewWhereUniqueInput
    update: ViewUpdateWithoutUserInput
    create: ViewCreateWithoutUserInput
  }

  export type UserCreateWithoutCommentsInput = {
    id?: string
    createdAt?: Date | string
    username: string
    email: string
    avatar?: string
    cover?: string
    about?: string
    videos?: VideoCreateManyWithoutUserInput
    videoLikes?: VideoLikeCreateManyWithoutUserInput
    subscribers?: SubscriptionCreateManyWithoutSubscriberInput
    subscribedTo?: SubscriptionCreateManyWithoutSubscribedToInput
    views?: ViewCreateManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutcommentsInput = {
    where: UserWhereUniqueInput
    create: UserCreateWithoutCommentsInput
  }

  export type VideoCreateWithoutCommentsInput = {
    id?: string
    createdAt?: Date | string
    title: string
    description?: XOR<string, null>
    url: string
    thumbnail: string
    user: UserCreateOneWithoutVideosInput
    videoLikes?: VideoLikeCreateManyWithoutVideoInput
    views?: ViewCreateManyWithoutVideoInput
  }

  export type VideoCreateOrConnectWithoutcommentsInput = {
    where: VideoWhereUniqueInput
    create: VideoCreateWithoutCommentsInput
  }

  export type UserUpdateWithoutCommentsInput = {
    id?: XOR<string, StringFieldUpdateOperationsInput>
    createdAt?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
    username?: XOR<string, StringFieldUpdateOperationsInput>
    email?: XOR<string, StringFieldUpdateOperationsInput>
    avatar?: XOR<string, StringFieldUpdateOperationsInput>
    cover?: XOR<string, StringFieldUpdateOperationsInput>
    about?: XOR<string, StringFieldUpdateOperationsInput>
    videos?: VideoUpdateManyWithoutUserInput
    videoLikes?: VideoLikeUpdateManyWithoutUserInput
    subscribers?: SubscriptionUpdateManyWithoutSubscriberInput
    subscribedTo?: SubscriptionUpdateManyWithoutSubscribedToInput
    views?: ViewUpdateManyWithoutUserInput
  }

  export type UserUpsertWithoutCommentsInput = {
    update: UserUpdateWithoutCommentsInput
    create: UserCreateWithoutCommentsInput
  }

  export type VideoUpdateWithoutCommentsInput = {
    id?: XOR<string, StringFieldUpdateOperationsInput>
    createdAt?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
    title?: XOR<string, StringFieldUpdateOperationsInput>
    description?: string | NullableStringFieldUpdateOperationsInput | null
    url?: XOR<string, StringFieldUpdateOperationsInput>
    thumbnail?: XOR<string, StringFieldUpdateOperationsInput>
    user?: UserUpdateOneRequiredWithoutVideosInput
    videoLikes?: VideoLikeUpdateManyWithoutVideoInput
    views?: ViewUpdateManyWithoutVideoInput
  }

  export type VideoUpsertWithoutCommentsInput = {
    update: VideoUpdateWithoutCommentsInput
    create: VideoCreateWithoutCommentsInput
  }

  export type UserCreateWithoutSubscribersInput = {
    id?: string
    createdAt?: Date | string
    username: string
    email: string
    avatar?: string
    cover?: string
    about?: string
    videos?: VideoCreateManyWithoutUserInput
    videoLikes?: VideoLikeCreateManyWithoutUserInput
    comments?: CommentCreateManyWithoutUserInput
    subscribedTo?: SubscriptionCreateManyWithoutSubscribedToInput
    views?: ViewCreateManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutsubscribersInput = {
    where: UserWhereUniqueInput
    create: UserCreateWithoutSubscribersInput
  }

  export type UserCreateWithoutSubscribedToInput = {
    id?: string
    createdAt?: Date | string
    username: string
    email: string
    avatar?: string
    cover?: string
    about?: string
    videos?: VideoCreateManyWithoutUserInput
    videoLikes?: VideoLikeCreateManyWithoutUserInput
    comments?: CommentCreateManyWithoutUserInput
    subscribers?: SubscriptionCreateManyWithoutSubscriberInput
    views?: ViewCreateManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutsubscribedToInput = {
    where: UserWhereUniqueInput
    create: UserCreateWithoutSubscribedToInput
  }

  export type UserUpdateWithoutSubscribersInput = {
    id?: XOR<string, StringFieldUpdateOperationsInput>
    createdAt?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
    username?: XOR<string, StringFieldUpdateOperationsInput>
    email?: XOR<string, StringFieldUpdateOperationsInput>
    avatar?: XOR<string, StringFieldUpdateOperationsInput>
    cover?: XOR<string, StringFieldUpdateOperationsInput>
    about?: XOR<string, StringFieldUpdateOperationsInput>
    videos?: VideoUpdateManyWithoutUserInput
    videoLikes?: VideoLikeUpdateManyWithoutUserInput
    comments?: CommentUpdateManyWithoutUserInput
    subscribedTo?: SubscriptionUpdateManyWithoutSubscribedToInput
    views?: ViewUpdateManyWithoutUserInput
  }

  export type UserUpsertWithoutSubscribersInput = {
    update: UserUpdateWithoutSubscribersInput
    create: UserCreateWithoutSubscribersInput
  }

  export type UserUpdateWithoutSubscribedToInput = {
    id?: XOR<string, StringFieldUpdateOperationsInput>
    createdAt?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
    username?: XOR<string, StringFieldUpdateOperationsInput>
    email?: XOR<string, StringFieldUpdateOperationsInput>
    avatar?: XOR<string, StringFieldUpdateOperationsInput>
    cover?: XOR<string, StringFieldUpdateOperationsInput>
    about?: XOR<string, StringFieldUpdateOperationsInput>
    videos?: VideoUpdateManyWithoutUserInput
    videoLikes?: VideoLikeUpdateManyWithoutUserInput
    comments?: CommentUpdateManyWithoutUserInput
    subscribers?: SubscriptionUpdateManyWithoutSubscriberInput
    views?: ViewUpdateManyWithoutUserInput
  }

  export type UserUpsertWithoutSubscribedToInput = {
    update: UserUpdateWithoutSubscribedToInput
    create: UserCreateWithoutSubscribedToInput
  }

  export type UserCreateWithoutVideosInput = {
    id?: string
    createdAt?: Date | string
    username: string
    email: string
    avatar?: string
    cover?: string
    about?: string
    videoLikes?: VideoLikeCreateManyWithoutUserInput
    comments?: CommentCreateManyWithoutUserInput
    subscribers?: SubscriptionCreateManyWithoutSubscriberInput
    subscribedTo?: SubscriptionCreateManyWithoutSubscribedToInput
    views?: ViewCreateManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutvideosInput = {
    where: UserWhereUniqueInput
    create: UserCreateWithoutVideosInput
  }

  export type VideoLikeCreateWithoutVideoInput = {
    id?: string
    createdAt?: Date | string
    like?: number
    user: UserCreateOneWithoutVideoLikesInput
  }

  export type VideoLikeCreateOrConnectWithoutvideoInput = {
    where: VideoLikeWhereUniqueInput
    create: VideoLikeCreateWithoutVideoInput
  }

  export type CommentCreateWithoutVideoInput = {
    id?: string
    createdAt?: Date | string
    text: string
    user: UserCreateOneWithoutCommentsInput
  }

  export type CommentCreateOrConnectWithoutvideoInput = {
    where: CommentWhereUniqueInput
    create: CommentCreateWithoutVideoInput
  }

  export type ViewCreateWithoutVideoInput = {
    id?: string
    createdAt?: Date | string
    user?: UserCreateOneWithoutViewsInput
  }

  export type ViewCreateOrConnectWithoutvideoInput = {
    where: ViewWhereUniqueInput
    create: ViewCreateWithoutVideoInput
  }

  export type UserUpdateWithoutVideosInput = {
    id?: XOR<string, StringFieldUpdateOperationsInput>
    createdAt?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
    username?: XOR<string, StringFieldUpdateOperationsInput>
    email?: XOR<string, StringFieldUpdateOperationsInput>
    avatar?: XOR<string, StringFieldUpdateOperationsInput>
    cover?: XOR<string, StringFieldUpdateOperationsInput>
    about?: XOR<string, StringFieldUpdateOperationsInput>
    videoLikes?: VideoLikeUpdateManyWithoutUserInput
    comments?: CommentUpdateManyWithoutUserInput
    subscribers?: SubscriptionUpdateManyWithoutSubscriberInput
    subscribedTo?: SubscriptionUpdateManyWithoutSubscribedToInput
    views?: ViewUpdateManyWithoutUserInput
  }

  export type UserUpsertWithoutVideosInput = {
    update: UserUpdateWithoutVideosInput
    create: UserCreateWithoutVideosInput
  }

  export type VideoLikeUpdateWithWhereUniqueWithoutVideoInput = {
    where: VideoLikeWhereUniqueInput
    data: VideoLikeUpdateWithoutVideoInput
  }

  export type VideoLikeUpdateManyWithWhereWithoutVideoInput = {
    where: VideoLikeScalarWhereInput
    data: VideoLikeUpdateManyMutationInput
  }

  export type VideoLikeUpsertWithWhereUniqueWithoutVideoInput = {
    where: VideoLikeWhereUniqueInput
    update: VideoLikeUpdateWithoutVideoInput
    create: VideoLikeCreateWithoutVideoInput
  }

  export type CommentUpdateWithWhereUniqueWithoutVideoInput = {
    where: CommentWhereUniqueInput
    data: CommentUpdateWithoutVideoInput
  }

  export type CommentUpdateManyWithWhereWithoutVideoInput = {
    where: CommentScalarWhereInput
    data: CommentUpdateManyMutationInput
  }

  export type CommentUpsertWithWhereUniqueWithoutVideoInput = {
    where: CommentWhereUniqueInput
    update: CommentUpdateWithoutVideoInput
    create: CommentCreateWithoutVideoInput
  }

  export type ViewUpdateWithWhereUniqueWithoutVideoInput = {
    where: ViewWhereUniqueInput
    data: ViewUpdateWithoutVideoInput
  }

  export type ViewUpdateManyWithWhereWithoutVideoInput = {
    where: ViewScalarWhereInput
    data: ViewUpdateManyMutationInput
  }

  export type ViewUpsertWithWhereUniqueWithoutVideoInput = {
    where: ViewWhereUniqueInput
    update: ViewUpdateWithoutVideoInput
    create: ViewCreateWithoutVideoInput
  }

  export type UserCreateWithoutVideoLikesInput = {
    id?: string
    createdAt?: Date | string
    username: string
    email: string
    avatar?: string
    cover?: string
    about?: string
    videos?: VideoCreateManyWithoutUserInput
    comments?: CommentCreateManyWithoutUserInput
    subscribers?: SubscriptionCreateManyWithoutSubscriberInput
    subscribedTo?: SubscriptionCreateManyWithoutSubscribedToInput
    views?: ViewCreateManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutvideoLikesInput = {
    where: UserWhereUniqueInput
    create: UserCreateWithoutVideoLikesInput
  }

  export type VideoCreateWithoutVideoLikesInput = {
    id?: string
    createdAt?: Date | string
    title: string
    description?: XOR<string, null>
    url: string
    thumbnail: string
    user: UserCreateOneWithoutVideosInput
    comments?: CommentCreateManyWithoutVideoInput
    views?: ViewCreateManyWithoutVideoInput
  }

  export type VideoCreateOrConnectWithoutvideoLikesInput = {
    where: VideoWhereUniqueInput
    create: VideoCreateWithoutVideoLikesInput
  }

  export type UserUpdateWithoutVideoLikesInput = {
    id?: XOR<string, StringFieldUpdateOperationsInput>
    createdAt?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
    username?: XOR<string, StringFieldUpdateOperationsInput>
    email?: XOR<string, StringFieldUpdateOperationsInput>
    avatar?: XOR<string, StringFieldUpdateOperationsInput>
    cover?: XOR<string, StringFieldUpdateOperationsInput>
    about?: XOR<string, StringFieldUpdateOperationsInput>
    videos?: VideoUpdateManyWithoutUserInput
    comments?: CommentUpdateManyWithoutUserInput
    subscribers?: SubscriptionUpdateManyWithoutSubscriberInput
    subscribedTo?: SubscriptionUpdateManyWithoutSubscribedToInput
    views?: ViewUpdateManyWithoutUserInput
  }

  export type UserUpsertWithoutVideoLikesInput = {
    update: UserUpdateWithoutVideoLikesInput
    create: UserCreateWithoutVideoLikesInput
  }

  export type VideoUpdateWithoutVideoLikesInput = {
    id?: XOR<string, StringFieldUpdateOperationsInput>
    createdAt?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
    title?: XOR<string, StringFieldUpdateOperationsInput>
    description?: string | NullableStringFieldUpdateOperationsInput | null
    url?: XOR<string, StringFieldUpdateOperationsInput>
    thumbnail?: XOR<string, StringFieldUpdateOperationsInput>
    user?: UserUpdateOneRequiredWithoutVideosInput
    comments?: CommentUpdateManyWithoutVideoInput
    views?: ViewUpdateManyWithoutVideoInput
  }

  export type VideoUpsertWithoutVideoLikesInput = {
    update: VideoUpdateWithoutVideoLikesInput
    create: VideoCreateWithoutVideoLikesInput
  }

  export type UserCreateWithoutViewsInput = {
    id?: string
    createdAt?: Date | string
    username: string
    email: string
    avatar?: string
    cover?: string
    about?: string
    videos?: VideoCreateManyWithoutUserInput
    videoLikes?: VideoLikeCreateManyWithoutUserInput
    comments?: CommentCreateManyWithoutUserInput
    subscribers?: SubscriptionCreateManyWithoutSubscriberInput
    subscribedTo?: SubscriptionCreateManyWithoutSubscribedToInput
  }

  export type UserCreateOrConnectWithoutviewsInput = {
    where: UserWhereUniqueInput
    create: UserCreateWithoutViewsInput
  }

  export type VideoCreateWithoutViewsInput = {
    id?: string
    createdAt?: Date | string
    title: string
    description?: XOR<string, null>
    url: string
    thumbnail: string
    user: UserCreateOneWithoutVideosInput
    videoLikes?: VideoLikeCreateManyWithoutVideoInput
    comments?: CommentCreateManyWithoutVideoInput
  }

  export type VideoCreateOrConnectWithoutviewsInput = {
    where: VideoWhereUniqueInput
    create: VideoCreateWithoutViewsInput
  }

  export type UserUpdateWithoutViewsInput = {
    id?: XOR<string, StringFieldUpdateOperationsInput>
    createdAt?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
    username?: XOR<string, StringFieldUpdateOperationsInput>
    email?: XOR<string, StringFieldUpdateOperationsInput>
    avatar?: XOR<string, StringFieldUpdateOperationsInput>
    cover?: XOR<string, StringFieldUpdateOperationsInput>
    about?: XOR<string, StringFieldUpdateOperationsInput>
    videos?: VideoUpdateManyWithoutUserInput
    videoLikes?: VideoLikeUpdateManyWithoutUserInput
    comments?: CommentUpdateManyWithoutUserInput
    subscribers?: SubscriptionUpdateManyWithoutSubscriberInput
    subscribedTo?: SubscriptionUpdateManyWithoutSubscribedToInput
  }

  export type UserUpsertWithoutViewsInput = {
    update: UserUpdateWithoutViewsInput
    create: UserCreateWithoutViewsInput
  }

  export type VideoUpdateWithoutViewsInput = {
    id?: XOR<string, StringFieldUpdateOperationsInput>
    createdAt?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
    title?: XOR<string, StringFieldUpdateOperationsInput>
    description?: string | NullableStringFieldUpdateOperationsInput | null
    url?: XOR<string, StringFieldUpdateOperationsInput>
    thumbnail?: XOR<string, StringFieldUpdateOperationsInput>
    user?: UserUpdateOneRequiredWithoutVideosInput
    videoLikes?: VideoLikeUpdateManyWithoutVideoInput
    comments?: CommentUpdateManyWithoutVideoInput
  }

  export type VideoUpsertWithoutViewsInput = {
    update: VideoUpdateWithoutViewsInput
    create: VideoCreateWithoutViewsInput
  }

  export type VideoUpdateWithoutUserInput = {
    id?: XOR<string, StringFieldUpdateOperationsInput>
    createdAt?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
    title?: XOR<string, StringFieldUpdateOperationsInput>
    description?: string | NullableStringFieldUpdateOperationsInput | null
    url?: XOR<string, StringFieldUpdateOperationsInput>
    thumbnail?: XOR<string, StringFieldUpdateOperationsInput>
    videoLikes?: VideoLikeUpdateManyWithoutVideoInput
    comments?: CommentUpdateManyWithoutVideoInput
    views?: ViewUpdateManyWithoutVideoInput
  }

  export type VideoLikeUpdateWithoutUserInput = {
    id?: XOR<string, StringFieldUpdateOperationsInput>
    createdAt?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
    like?: XOR<number, IntFieldUpdateOperationsInput>
    video?: VideoUpdateOneRequiredWithoutVideoLikesInput
  }

  export type CommentUpdateWithoutUserInput = {
    id?: XOR<string, StringFieldUpdateOperationsInput>
    createdAt?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
    text?: XOR<string, StringFieldUpdateOperationsInput>
    video?: VideoUpdateOneRequiredWithoutCommentsInput
  }

  export type SubscriptionUpdateWithoutSubscriberInput = {
    id?: XOR<string, StringFieldUpdateOperationsInput>
    createdAt?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
    subscribedTo?: UserUpdateOneRequiredWithoutSubscribedToInput
  }

  export type SubscriptionUpdateWithoutSubscribedToInput = {
    id?: XOR<string, StringFieldUpdateOperationsInput>
    createdAt?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
    subscriber?: UserUpdateOneRequiredWithoutSubscribersInput
  }

  export type ViewUpdateWithoutUserInput = {
    id?: XOR<string, StringFieldUpdateOperationsInput>
    createdAt?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
    video?: VideoUpdateOneRequiredWithoutViewsInput
  }

  export type VideoLikeUpdateWithoutVideoInput = {
    id?: XOR<string, StringFieldUpdateOperationsInput>
    createdAt?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
    like?: XOR<number, IntFieldUpdateOperationsInput>
    user?: UserUpdateOneRequiredWithoutVideoLikesInput
  }

  export type CommentUpdateWithoutVideoInput = {
    id?: XOR<string, StringFieldUpdateOperationsInput>
    createdAt?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
    text?: XOR<string, StringFieldUpdateOperationsInput>
    user?: UserUpdateOneRequiredWithoutCommentsInput
  }

  export type ViewUpdateWithoutVideoInput = {
    id?: XOR<string, StringFieldUpdateOperationsInput>
    createdAt?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
    user?: UserUpdateOneWithoutViewsInput
  }



  /**
   * Batch Payload for updateMany & deleteMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}

/*
* Exports for compatiblity introduced in 2.12.0
* Please import from the Prisma namespace instead
*/

/**
 * @deprecated Renamed to `Prisma.UserDistinctFieldEnum`
 */
export import UserDistinctFieldEnum = Prisma.UserDistinctFieldEnum

/**
 * @deprecated Renamed to `Prisma.CommentDistinctFieldEnum`
 */
export import CommentDistinctFieldEnum = Prisma.CommentDistinctFieldEnum

/**
 * @deprecated Renamed to `Prisma.SubscriptionDistinctFieldEnum`
 */
export import SubscriptionDistinctFieldEnum = Prisma.SubscriptionDistinctFieldEnum

/**
 * @deprecated Renamed to `Prisma.VideoDistinctFieldEnum`
 */
export import VideoDistinctFieldEnum = Prisma.VideoDistinctFieldEnum

/**
 * @deprecated Renamed to `Prisma.VideoLikeDistinctFieldEnum`
 */
export import VideoLikeDistinctFieldEnum = Prisma.VideoLikeDistinctFieldEnum

/**
 * @deprecated Renamed to `Prisma.ViewDistinctFieldEnum`
 */
export import ViewDistinctFieldEnum = Prisma.ViewDistinctFieldEnum

/**
 * @deprecated Renamed to `Prisma.SortOrder`
 */
export import SortOrder = Prisma.SortOrder

/**
 * @deprecated Renamed to `Prisma.QueryMode`
 */
export import QueryMode = Prisma.QueryMode

/**
 * @deprecated Renamed to `Prisma.ModelName`
 */
export import ModelName = Prisma.ModelName

/**
 * @deprecated Renamed to `Prisma.AggregateUser`
 */
export import AggregateUser = Prisma.AggregateUser

/**
 * @deprecated Renamed to `Prisma.AggregateUserArgs`
 */
export import AggregateUserArgs = Prisma.AggregateUserArgs

/**
 * @deprecated Renamed to `Prisma.UserSelect`
 */
export import UserSelect = Prisma.UserSelect

/**
 * @deprecated Renamed to `Prisma.UserInclude`
 */
export import UserInclude = Prisma.UserInclude

/**
 * @deprecated Renamed to `Prisma.FindUniqueUserArgs`
 */
export import FindUniqueUserArgs = Prisma.FindUniqueUserArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstUserArgs`
 */
export import FindFirstUserArgs = Prisma.FindFirstUserArgs

/**
 * @deprecated Renamed to `Prisma.FindManyUserArgs`
 */
export import FindManyUserArgs = Prisma.FindManyUserArgs

/**
 * @deprecated Renamed to `Prisma.UserCreateArgs`
 */
export import UserCreateArgs = Prisma.UserCreateArgs

/**
 * @deprecated Renamed to `Prisma.UserUpdateArgs`
 */
export import UserUpdateArgs = Prisma.UserUpdateArgs

/**
 * @deprecated Renamed to `Prisma.UserUpdateManyArgs`
 */
export import UserUpdateManyArgs = Prisma.UserUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.UserUpsertArgs`
 */
export import UserUpsertArgs = Prisma.UserUpsertArgs

/**
 * @deprecated Renamed to `Prisma.UserDeleteArgs`
 */
export import UserDeleteArgs = Prisma.UserDeleteArgs

/**
 * @deprecated Renamed to `Prisma.UserDeleteManyArgs`
 */
export import UserDeleteManyArgs = Prisma.UserDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateComment`
 */
export import AggregateComment = Prisma.AggregateComment

/**
 * @deprecated Renamed to `Prisma.AggregateCommentArgs`
 */
export import AggregateCommentArgs = Prisma.AggregateCommentArgs

/**
 * @deprecated Renamed to `Prisma.CommentSelect`
 */
export import CommentSelect = Prisma.CommentSelect

/**
 * @deprecated Renamed to `Prisma.CommentInclude`
 */
export import CommentInclude = Prisma.CommentInclude

/**
 * @deprecated Renamed to `Prisma.FindUniqueCommentArgs`
 */
export import FindUniqueCommentArgs = Prisma.FindUniqueCommentArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstCommentArgs`
 */
export import FindFirstCommentArgs = Prisma.FindFirstCommentArgs

/**
 * @deprecated Renamed to `Prisma.FindManyCommentArgs`
 */
export import FindManyCommentArgs = Prisma.FindManyCommentArgs

/**
 * @deprecated Renamed to `Prisma.CommentCreateArgs`
 */
export import CommentCreateArgs = Prisma.CommentCreateArgs

/**
 * @deprecated Renamed to `Prisma.CommentUpdateArgs`
 */
export import CommentUpdateArgs = Prisma.CommentUpdateArgs

/**
 * @deprecated Renamed to `Prisma.CommentUpdateManyArgs`
 */
export import CommentUpdateManyArgs = Prisma.CommentUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.CommentUpsertArgs`
 */
export import CommentUpsertArgs = Prisma.CommentUpsertArgs

/**
 * @deprecated Renamed to `Prisma.CommentDeleteArgs`
 */
export import CommentDeleteArgs = Prisma.CommentDeleteArgs

/**
 * @deprecated Renamed to `Prisma.CommentDeleteManyArgs`
 */
export import CommentDeleteManyArgs = Prisma.CommentDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateSubscription`
 */
export import AggregateSubscription = Prisma.AggregateSubscription

/**
 * @deprecated Renamed to `Prisma.AggregateSubscriptionArgs`
 */
export import AggregateSubscriptionArgs = Prisma.AggregateSubscriptionArgs

/**
 * @deprecated Renamed to `Prisma.SubscriptionSelect`
 */
export import SubscriptionSelect = Prisma.SubscriptionSelect

/**
 * @deprecated Renamed to `Prisma.SubscriptionInclude`
 */
export import SubscriptionInclude = Prisma.SubscriptionInclude

/**
 * @deprecated Renamed to `Prisma.FindUniqueSubscriptionArgs`
 */
export import FindUniqueSubscriptionArgs = Prisma.FindUniqueSubscriptionArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstSubscriptionArgs`
 */
export import FindFirstSubscriptionArgs = Prisma.FindFirstSubscriptionArgs

/**
 * @deprecated Renamed to `Prisma.FindManySubscriptionArgs`
 */
export import FindManySubscriptionArgs = Prisma.FindManySubscriptionArgs

/**
 * @deprecated Renamed to `Prisma.SubscriptionCreateArgs`
 */
export import SubscriptionCreateArgs = Prisma.SubscriptionCreateArgs

/**
 * @deprecated Renamed to `Prisma.SubscriptionUpdateArgs`
 */
export import SubscriptionUpdateArgs = Prisma.SubscriptionUpdateArgs

/**
 * @deprecated Renamed to `Prisma.SubscriptionUpdateManyArgs`
 */
export import SubscriptionUpdateManyArgs = Prisma.SubscriptionUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.SubscriptionUpsertArgs`
 */
export import SubscriptionUpsertArgs = Prisma.SubscriptionUpsertArgs

/**
 * @deprecated Renamed to `Prisma.SubscriptionDeleteArgs`
 */
export import SubscriptionDeleteArgs = Prisma.SubscriptionDeleteArgs

/**
 * @deprecated Renamed to `Prisma.SubscriptionDeleteManyArgs`
 */
export import SubscriptionDeleteManyArgs = Prisma.SubscriptionDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateVideo`
 */
export import AggregateVideo = Prisma.AggregateVideo

/**
 * @deprecated Renamed to `Prisma.AggregateVideoArgs`
 */
export import AggregateVideoArgs = Prisma.AggregateVideoArgs

/**
 * @deprecated Renamed to `Prisma.VideoSelect`
 */
export import VideoSelect = Prisma.VideoSelect

/**
 * @deprecated Renamed to `Prisma.VideoInclude`
 */
export import VideoInclude = Prisma.VideoInclude

/**
 * @deprecated Renamed to `Prisma.FindUniqueVideoArgs`
 */
export import FindUniqueVideoArgs = Prisma.FindUniqueVideoArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstVideoArgs`
 */
export import FindFirstVideoArgs = Prisma.FindFirstVideoArgs

/**
 * @deprecated Renamed to `Prisma.FindManyVideoArgs`
 */
export import FindManyVideoArgs = Prisma.FindManyVideoArgs

/**
 * @deprecated Renamed to `Prisma.VideoCreateArgs`
 */
export import VideoCreateArgs = Prisma.VideoCreateArgs

/**
 * @deprecated Renamed to `Prisma.VideoUpdateArgs`
 */
export import VideoUpdateArgs = Prisma.VideoUpdateArgs

/**
 * @deprecated Renamed to `Prisma.VideoUpdateManyArgs`
 */
export import VideoUpdateManyArgs = Prisma.VideoUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.VideoUpsertArgs`
 */
export import VideoUpsertArgs = Prisma.VideoUpsertArgs

/**
 * @deprecated Renamed to `Prisma.VideoDeleteArgs`
 */
export import VideoDeleteArgs = Prisma.VideoDeleteArgs

/**
 * @deprecated Renamed to `Prisma.VideoDeleteManyArgs`
 */
export import VideoDeleteManyArgs = Prisma.VideoDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateVideoLike`
 */
export import AggregateVideoLike = Prisma.AggregateVideoLike

/**
 * @deprecated Renamed to `Prisma.VideoLikeAvgAggregateOutputType`
 */
export import VideoLikeAvgAggregateOutputType = Prisma.VideoLikeAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.VideoLikeSumAggregateOutputType`
 */
export import VideoLikeSumAggregateOutputType = Prisma.VideoLikeSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.VideoLikeMinAggregateOutputType`
 */
export import VideoLikeMinAggregateOutputType = Prisma.VideoLikeMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.VideoLikeMaxAggregateOutputType`
 */
export import VideoLikeMaxAggregateOutputType = Prisma.VideoLikeMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateVideoLikeArgs`
 */
export import AggregateVideoLikeArgs = Prisma.AggregateVideoLikeArgs

/**
 * @deprecated Renamed to `Prisma.VideoLikeAvgAggregateInputType`
 */
export import VideoLikeAvgAggregateInputType = Prisma.VideoLikeAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.VideoLikeSumAggregateInputType`
 */
export import VideoLikeSumAggregateInputType = Prisma.VideoLikeSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.VideoLikeMinAggregateInputType`
 */
export import VideoLikeMinAggregateInputType = Prisma.VideoLikeMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.VideoLikeMaxAggregateInputType`
 */
export import VideoLikeMaxAggregateInputType = Prisma.VideoLikeMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.VideoLikeSelect`
 */
export import VideoLikeSelect = Prisma.VideoLikeSelect

/**
 * @deprecated Renamed to `Prisma.VideoLikeInclude`
 */
export import VideoLikeInclude = Prisma.VideoLikeInclude

/**
 * @deprecated Renamed to `Prisma.FindUniqueVideoLikeArgs`
 */
export import FindUniqueVideoLikeArgs = Prisma.FindUniqueVideoLikeArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstVideoLikeArgs`
 */
export import FindFirstVideoLikeArgs = Prisma.FindFirstVideoLikeArgs

/**
 * @deprecated Renamed to `Prisma.FindManyVideoLikeArgs`
 */
export import FindManyVideoLikeArgs = Prisma.FindManyVideoLikeArgs

/**
 * @deprecated Renamed to `Prisma.VideoLikeCreateArgs`
 */
export import VideoLikeCreateArgs = Prisma.VideoLikeCreateArgs

/**
 * @deprecated Renamed to `Prisma.VideoLikeUpdateArgs`
 */
export import VideoLikeUpdateArgs = Prisma.VideoLikeUpdateArgs

/**
 * @deprecated Renamed to `Prisma.VideoLikeUpdateManyArgs`
 */
export import VideoLikeUpdateManyArgs = Prisma.VideoLikeUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.VideoLikeUpsertArgs`
 */
export import VideoLikeUpsertArgs = Prisma.VideoLikeUpsertArgs

/**
 * @deprecated Renamed to `Prisma.VideoLikeDeleteArgs`
 */
export import VideoLikeDeleteArgs = Prisma.VideoLikeDeleteArgs

/**
 * @deprecated Renamed to `Prisma.VideoLikeDeleteManyArgs`
 */
export import VideoLikeDeleteManyArgs = Prisma.VideoLikeDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateView`
 */
export import AggregateView = Prisma.AggregateView

/**
 * @deprecated Renamed to `Prisma.AggregateViewArgs`
 */
export import AggregateViewArgs = Prisma.AggregateViewArgs

/**
 * @deprecated Renamed to `Prisma.ViewSelect`
 */
export import ViewSelect = Prisma.ViewSelect

/**
 * @deprecated Renamed to `Prisma.ViewInclude`
 */
export import ViewInclude = Prisma.ViewInclude

/**
 * @deprecated Renamed to `Prisma.FindUniqueViewArgs`
 */
export import FindUniqueViewArgs = Prisma.FindUniqueViewArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstViewArgs`
 */
export import FindFirstViewArgs = Prisma.FindFirstViewArgs

/**
 * @deprecated Renamed to `Prisma.FindManyViewArgs`
 */
export import FindManyViewArgs = Prisma.FindManyViewArgs

/**
 * @deprecated Renamed to `Prisma.ViewCreateArgs`
 */
export import ViewCreateArgs = Prisma.ViewCreateArgs

/**
 * @deprecated Renamed to `Prisma.ViewUpdateArgs`
 */
export import ViewUpdateArgs = Prisma.ViewUpdateArgs

/**
 * @deprecated Renamed to `Prisma.ViewUpdateManyArgs`
 */
export import ViewUpdateManyArgs = Prisma.ViewUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.ViewUpsertArgs`
 */
export import ViewUpsertArgs = Prisma.ViewUpsertArgs

/**
 * @deprecated Renamed to `Prisma.ViewDeleteArgs`
 */
export import ViewDeleteArgs = Prisma.ViewDeleteArgs

/**
 * @deprecated Renamed to `Prisma.ViewDeleteManyArgs`
 */
export import ViewDeleteManyArgs = Prisma.ViewDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.UserWhereInput`
 */
export import UserWhereInput = Prisma.UserWhereInput

/**
 * @deprecated Renamed to `Prisma.UserOrderByInput`
 */
export import UserOrderByInput = Prisma.UserOrderByInput

/**
 * @deprecated Renamed to `Prisma.UserWhereUniqueInput`
 */
export import UserWhereUniqueInput = Prisma.UserWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.CommentWhereInput`
 */
export import CommentWhereInput = Prisma.CommentWhereInput

/**
 * @deprecated Renamed to `Prisma.CommentOrderByInput`
 */
export import CommentOrderByInput = Prisma.CommentOrderByInput

/**
 * @deprecated Renamed to `Prisma.CommentWhereUniqueInput`
 */
export import CommentWhereUniqueInput = Prisma.CommentWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.SubscriptionWhereInput`
 */
export import SubscriptionWhereInput = Prisma.SubscriptionWhereInput

/**
 * @deprecated Renamed to `Prisma.SubscriptionOrderByInput`
 */
export import SubscriptionOrderByInput = Prisma.SubscriptionOrderByInput

/**
 * @deprecated Renamed to `Prisma.SubscriptionWhereUniqueInput`
 */
export import SubscriptionWhereUniqueInput = Prisma.SubscriptionWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.VideoWhereInput`
 */
export import VideoWhereInput = Prisma.VideoWhereInput

/**
 * @deprecated Renamed to `Prisma.VideoOrderByInput`
 */
export import VideoOrderByInput = Prisma.VideoOrderByInput

/**
 * @deprecated Renamed to `Prisma.VideoWhereUniqueInput`
 */
export import VideoWhereUniqueInput = Prisma.VideoWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.VideoLikeWhereInput`
 */
export import VideoLikeWhereInput = Prisma.VideoLikeWhereInput

/**
 * @deprecated Renamed to `Prisma.VideoLikeOrderByInput`
 */
export import VideoLikeOrderByInput = Prisma.VideoLikeOrderByInput

/**
 * @deprecated Renamed to `Prisma.VideoLikeWhereUniqueInput`
 */
export import VideoLikeWhereUniqueInput = Prisma.VideoLikeWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.ViewWhereInput`
 */
export import ViewWhereInput = Prisma.ViewWhereInput

/**
 * @deprecated Renamed to `Prisma.ViewOrderByInput`
 */
export import ViewOrderByInput = Prisma.ViewOrderByInput

/**
 * @deprecated Renamed to `Prisma.ViewWhereUniqueInput`
 */
export import ViewWhereUniqueInput = Prisma.ViewWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.UserCreateInput`
 */
export import UserCreateInput = Prisma.UserCreateInput

/**
 * @deprecated Renamed to `Prisma.UserUpdateInput`
 */
export import UserUpdateInput = Prisma.UserUpdateInput

/**
 * @deprecated Renamed to `Prisma.UserUpdateManyMutationInput`
 */
export import UserUpdateManyMutationInput = Prisma.UserUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.CommentCreateInput`
 */
export import CommentCreateInput = Prisma.CommentCreateInput

/**
 * @deprecated Renamed to `Prisma.CommentUpdateInput`
 */
export import CommentUpdateInput = Prisma.CommentUpdateInput

/**
 * @deprecated Renamed to `Prisma.CommentUpdateManyMutationInput`
 */
export import CommentUpdateManyMutationInput = Prisma.CommentUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.SubscriptionCreateInput`
 */
export import SubscriptionCreateInput = Prisma.SubscriptionCreateInput

/**
 * @deprecated Renamed to `Prisma.SubscriptionUpdateInput`
 */
export import SubscriptionUpdateInput = Prisma.SubscriptionUpdateInput

/**
 * @deprecated Renamed to `Prisma.SubscriptionUpdateManyMutationInput`
 */
export import SubscriptionUpdateManyMutationInput = Prisma.SubscriptionUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.VideoCreateInput`
 */
export import VideoCreateInput = Prisma.VideoCreateInput

/**
 * @deprecated Renamed to `Prisma.VideoUpdateInput`
 */
export import VideoUpdateInput = Prisma.VideoUpdateInput

/**
 * @deprecated Renamed to `Prisma.VideoUpdateManyMutationInput`
 */
export import VideoUpdateManyMutationInput = Prisma.VideoUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.VideoLikeCreateInput`
 */
export import VideoLikeCreateInput = Prisma.VideoLikeCreateInput

/**
 * @deprecated Renamed to `Prisma.VideoLikeUpdateInput`
 */
export import VideoLikeUpdateInput = Prisma.VideoLikeUpdateInput

/**
 * @deprecated Renamed to `Prisma.VideoLikeUpdateManyMutationInput`
 */
export import VideoLikeUpdateManyMutationInput = Prisma.VideoLikeUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.ViewCreateInput`
 */
export import ViewCreateInput = Prisma.ViewCreateInput

/**
 * @deprecated Renamed to `Prisma.ViewUpdateInput`
 */
export import ViewUpdateInput = Prisma.ViewUpdateInput

/**
 * @deprecated Renamed to `Prisma.ViewUpdateManyMutationInput`
 */
export import ViewUpdateManyMutationInput = Prisma.ViewUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.StringFilter`
 */
export import StringFilter = Prisma.StringFilter

/**
 * @deprecated Renamed to `Prisma.DateTimeFilter`
 */
export import DateTimeFilter = Prisma.DateTimeFilter

/**
 * @deprecated Renamed to `Prisma.VideoListRelationFilter`
 */
export import VideoListRelationFilter = Prisma.VideoListRelationFilter

/**
 * @deprecated Renamed to `Prisma.VideoLikeListRelationFilter`
 */
export import VideoLikeListRelationFilter = Prisma.VideoLikeListRelationFilter

/**
 * @deprecated Renamed to `Prisma.CommentListRelationFilter`
 */
export import CommentListRelationFilter = Prisma.CommentListRelationFilter

/**
 * @deprecated Renamed to `Prisma.SubscriptionListRelationFilter`
 */
export import SubscriptionListRelationFilter = Prisma.SubscriptionListRelationFilter

/**
 * @deprecated Renamed to `Prisma.ViewListRelationFilter`
 */
export import ViewListRelationFilter = Prisma.ViewListRelationFilter

/**
 * @deprecated Renamed to `Prisma.UserRelationFilter`
 */
export import UserRelationFilter = Prisma.UserRelationFilter

/**
 * @deprecated Renamed to `Prisma.VideoRelationFilter`
 */
export import VideoRelationFilter = Prisma.VideoRelationFilter

/**
 * @deprecated Renamed to `Prisma.StringNullableFilter`
 */
export import StringNullableFilter = Prisma.StringNullableFilter

/**
 * @deprecated Renamed to `Prisma.IntFilter`
 */
export import IntFilter = Prisma.IntFilter

/**
 * @deprecated Renamed to `Prisma.VideoCreateManyWithoutUserInput`
 */
export import VideoCreateManyWithoutUserInput = Prisma.VideoCreateManyWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.VideoLikeCreateManyWithoutUserInput`
 */
export import VideoLikeCreateManyWithoutUserInput = Prisma.VideoLikeCreateManyWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.CommentCreateManyWithoutUserInput`
 */
export import CommentCreateManyWithoutUserInput = Prisma.CommentCreateManyWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.SubscriptionCreateManyWithoutSubscriberInput`
 */
export import SubscriptionCreateManyWithoutSubscriberInput = Prisma.SubscriptionCreateManyWithoutSubscriberInput

/**
 * @deprecated Renamed to `Prisma.SubscriptionCreateManyWithoutSubscribedToInput`
 */
export import SubscriptionCreateManyWithoutSubscribedToInput = Prisma.SubscriptionCreateManyWithoutSubscribedToInput

/**
 * @deprecated Renamed to `Prisma.ViewCreateManyWithoutUserInput`
 */
export import ViewCreateManyWithoutUserInput = Prisma.ViewCreateManyWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.StringFieldUpdateOperationsInput`
 */
export import StringFieldUpdateOperationsInput = Prisma.StringFieldUpdateOperationsInput

/**
 * @deprecated Renamed to `Prisma.DateTimeFieldUpdateOperationsInput`
 */
export import DateTimeFieldUpdateOperationsInput = Prisma.DateTimeFieldUpdateOperationsInput

/**
 * @deprecated Renamed to `Prisma.VideoUpdateManyWithoutUserInput`
 */
export import VideoUpdateManyWithoutUserInput = Prisma.VideoUpdateManyWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.VideoLikeUpdateManyWithoutUserInput`
 */
export import VideoLikeUpdateManyWithoutUserInput = Prisma.VideoLikeUpdateManyWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.CommentUpdateManyWithoutUserInput`
 */
export import CommentUpdateManyWithoutUserInput = Prisma.CommentUpdateManyWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.SubscriptionUpdateManyWithoutSubscriberInput`
 */
export import SubscriptionUpdateManyWithoutSubscriberInput = Prisma.SubscriptionUpdateManyWithoutSubscriberInput

/**
 * @deprecated Renamed to `Prisma.SubscriptionUpdateManyWithoutSubscribedToInput`
 */
export import SubscriptionUpdateManyWithoutSubscribedToInput = Prisma.SubscriptionUpdateManyWithoutSubscribedToInput

/**
 * @deprecated Renamed to `Prisma.ViewUpdateManyWithoutUserInput`
 */
export import ViewUpdateManyWithoutUserInput = Prisma.ViewUpdateManyWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.UserCreateOneWithoutCommentsInput`
 */
export import UserCreateOneWithoutCommentsInput = Prisma.UserCreateOneWithoutCommentsInput

/**
 * @deprecated Renamed to `Prisma.VideoCreateOneWithoutCommentsInput`
 */
export import VideoCreateOneWithoutCommentsInput = Prisma.VideoCreateOneWithoutCommentsInput

/**
 * @deprecated Renamed to `Prisma.UserUpdateOneRequiredWithoutCommentsInput`
 */
export import UserUpdateOneRequiredWithoutCommentsInput = Prisma.UserUpdateOneRequiredWithoutCommentsInput

/**
 * @deprecated Renamed to `Prisma.VideoUpdateOneRequiredWithoutCommentsInput`
 */
export import VideoUpdateOneRequiredWithoutCommentsInput = Prisma.VideoUpdateOneRequiredWithoutCommentsInput

/**
 * @deprecated Renamed to `Prisma.UserCreateOneWithoutSubscribersInput`
 */
export import UserCreateOneWithoutSubscribersInput = Prisma.UserCreateOneWithoutSubscribersInput

/**
 * @deprecated Renamed to `Prisma.UserCreateOneWithoutSubscribedToInput`
 */
export import UserCreateOneWithoutSubscribedToInput = Prisma.UserCreateOneWithoutSubscribedToInput

/**
 * @deprecated Renamed to `Prisma.UserUpdateOneRequiredWithoutSubscribersInput`
 */
export import UserUpdateOneRequiredWithoutSubscribersInput = Prisma.UserUpdateOneRequiredWithoutSubscribersInput

/**
 * @deprecated Renamed to `Prisma.UserUpdateOneRequiredWithoutSubscribedToInput`
 */
export import UserUpdateOneRequiredWithoutSubscribedToInput = Prisma.UserUpdateOneRequiredWithoutSubscribedToInput

/**
 * @deprecated Renamed to `Prisma.UserCreateOneWithoutVideosInput`
 */
export import UserCreateOneWithoutVideosInput = Prisma.UserCreateOneWithoutVideosInput

/**
 * @deprecated Renamed to `Prisma.VideoLikeCreateManyWithoutVideoInput`
 */
export import VideoLikeCreateManyWithoutVideoInput = Prisma.VideoLikeCreateManyWithoutVideoInput

/**
 * @deprecated Renamed to `Prisma.CommentCreateManyWithoutVideoInput`
 */
export import CommentCreateManyWithoutVideoInput = Prisma.CommentCreateManyWithoutVideoInput

/**
 * @deprecated Renamed to `Prisma.ViewCreateManyWithoutVideoInput`
 */
export import ViewCreateManyWithoutVideoInput = Prisma.ViewCreateManyWithoutVideoInput

/**
 * @deprecated Renamed to `Prisma.NullableStringFieldUpdateOperationsInput`
 */
export import NullableStringFieldUpdateOperationsInput = Prisma.NullableStringFieldUpdateOperationsInput

/**
 * @deprecated Renamed to `Prisma.UserUpdateOneRequiredWithoutVideosInput`
 */
export import UserUpdateOneRequiredWithoutVideosInput = Prisma.UserUpdateOneRequiredWithoutVideosInput

/**
 * @deprecated Renamed to `Prisma.VideoLikeUpdateManyWithoutVideoInput`
 */
export import VideoLikeUpdateManyWithoutVideoInput = Prisma.VideoLikeUpdateManyWithoutVideoInput

/**
 * @deprecated Renamed to `Prisma.CommentUpdateManyWithoutVideoInput`
 */
export import CommentUpdateManyWithoutVideoInput = Prisma.CommentUpdateManyWithoutVideoInput

/**
 * @deprecated Renamed to `Prisma.ViewUpdateManyWithoutVideoInput`
 */
export import ViewUpdateManyWithoutVideoInput = Prisma.ViewUpdateManyWithoutVideoInput

/**
 * @deprecated Renamed to `Prisma.UserCreateOneWithoutVideoLikesInput`
 */
export import UserCreateOneWithoutVideoLikesInput = Prisma.UserCreateOneWithoutVideoLikesInput

/**
 * @deprecated Renamed to `Prisma.VideoCreateOneWithoutVideoLikesInput`
 */
export import VideoCreateOneWithoutVideoLikesInput = Prisma.VideoCreateOneWithoutVideoLikesInput

/**
 * @deprecated Renamed to `Prisma.IntFieldUpdateOperationsInput`
 */
export import IntFieldUpdateOperationsInput = Prisma.IntFieldUpdateOperationsInput

/**
 * @deprecated Renamed to `Prisma.UserUpdateOneRequiredWithoutVideoLikesInput`
 */
export import UserUpdateOneRequiredWithoutVideoLikesInput = Prisma.UserUpdateOneRequiredWithoutVideoLikesInput

/**
 * @deprecated Renamed to `Prisma.VideoUpdateOneRequiredWithoutVideoLikesInput`
 */
export import VideoUpdateOneRequiredWithoutVideoLikesInput = Prisma.VideoUpdateOneRequiredWithoutVideoLikesInput

/**
 * @deprecated Renamed to `Prisma.UserCreateOneWithoutViewsInput`
 */
export import UserCreateOneWithoutViewsInput = Prisma.UserCreateOneWithoutViewsInput

/**
 * @deprecated Renamed to `Prisma.VideoCreateOneWithoutViewsInput`
 */
export import VideoCreateOneWithoutViewsInput = Prisma.VideoCreateOneWithoutViewsInput

/**
 * @deprecated Renamed to `Prisma.UserUpdateOneWithoutViewsInput`
 */
export import UserUpdateOneWithoutViewsInput = Prisma.UserUpdateOneWithoutViewsInput

/**
 * @deprecated Renamed to `Prisma.VideoUpdateOneRequiredWithoutViewsInput`
 */
export import VideoUpdateOneRequiredWithoutViewsInput = Prisma.VideoUpdateOneRequiredWithoutViewsInput

/**
 * @deprecated Renamed to `Prisma.NestedStringFilter`
 */
export import NestedStringFilter = Prisma.NestedStringFilter

/**
 * @deprecated Renamed to `Prisma.NestedDateTimeFilter`
 */
export import NestedDateTimeFilter = Prisma.NestedDateTimeFilter

/**
 * @deprecated Renamed to `Prisma.NestedStringNullableFilter`
 */
export import NestedStringNullableFilter = Prisma.NestedStringNullableFilter

/**
 * @deprecated Renamed to `Prisma.NestedIntFilter`
 */
export import NestedIntFilter = Prisma.NestedIntFilter

/**
 * @deprecated Renamed to `Prisma.VideoCreateWithoutUserInput`
 */
export import VideoCreateWithoutUserInput = Prisma.VideoCreateWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.VideoCreateOrConnectWithoutuserInput`
 */
export import VideoCreateOrConnectWithoutuserInput = Prisma.VideoCreateOrConnectWithoutuserInput

/**
 * @deprecated Renamed to `Prisma.VideoLikeCreateWithoutUserInput`
 */
export import VideoLikeCreateWithoutUserInput = Prisma.VideoLikeCreateWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.VideoLikeCreateOrConnectWithoutuserInput`
 */
export import VideoLikeCreateOrConnectWithoutuserInput = Prisma.VideoLikeCreateOrConnectWithoutuserInput

/**
 * @deprecated Renamed to `Prisma.CommentCreateWithoutUserInput`
 */
export import CommentCreateWithoutUserInput = Prisma.CommentCreateWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.CommentCreateOrConnectWithoutuserInput`
 */
export import CommentCreateOrConnectWithoutuserInput = Prisma.CommentCreateOrConnectWithoutuserInput

/**
 * @deprecated Renamed to `Prisma.SubscriptionCreateWithoutSubscriberInput`
 */
export import SubscriptionCreateWithoutSubscriberInput = Prisma.SubscriptionCreateWithoutSubscriberInput

/**
 * @deprecated Renamed to `Prisma.SubscriptionCreateOrConnectWithoutsubscriberInput`
 */
export import SubscriptionCreateOrConnectWithoutsubscriberInput = Prisma.SubscriptionCreateOrConnectWithoutsubscriberInput

/**
 * @deprecated Renamed to `Prisma.SubscriptionCreateWithoutSubscribedToInput`
 */
export import SubscriptionCreateWithoutSubscribedToInput = Prisma.SubscriptionCreateWithoutSubscribedToInput

/**
 * @deprecated Renamed to `Prisma.SubscriptionCreateOrConnectWithoutsubscribedToInput`
 */
export import SubscriptionCreateOrConnectWithoutsubscribedToInput = Prisma.SubscriptionCreateOrConnectWithoutsubscribedToInput

/**
 * @deprecated Renamed to `Prisma.ViewCreateWithoutUserInput`
 */
export import ViewCreateWithoutUserInput = Prisma.ViewCreateWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.ViewCreateOrConnectWithoutuserInput`
 */
export import ViewCreateOrConnectWithoutuserInput = Prisma.ViewCreateOrConnectWithoutuserInput

/**
 * @deprecated Renamed to `Prisma.VideoUpdateWithWhereUniqueWithoutUserInput`
 */
export import VideoUpdateWithWhereUniqueWithoutUserInput = Prisma.VideoUpdateWithWhereUniqueWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.VideoUpdateManyWithWhereWithoutUserInput`
 */
export import VideoUpdateManyWithWhereWithoutUserInput = Prisma.VideoUpdateManyWithWhereWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.VideoScalarWhereInput`
 */
export import VideoScalarWhereInput = Prisma.VideoScalarWhereInput

/**
 * @deprecated Renamed to `Prisma.VideoUpsertWithWhereUniqueWithoutUserInput`
 */
export import VideoUpsertWithWhereUniqueWithoutUserInput = Prisma.VideoUpsertWithWhereUniqueWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.VideoLikeUpdateWithWhereUniqueWithoutUserInput`
 */
export import VideoLikeUpdateWithWhereUniqueWithoutUserInput = Prisma.VideoLikeUpdateWithWhereUniqueWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.VideoLikeUpdateManyWithWhereWithoutUserInput`
 */
export import VideoLikeUpdateManyWithWhereWithoutUserInput = Prisma.VideoLikeUpdateManyWithWhereWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.VideoLikeScalarWhereInput`
 */
export import VideoLikeScalarWhereInput = Prisma.VideoLikeScalarWhereInput

/**
 * @deprecated Renamed to `Prisma.VideoLikeUpsertWithWhereUniqueWithoutUserInput`
 */
export import VideoLikeUpsertWithWhereUniqueWithoutUserInput = Prisma.VideoLikeUpsertWithWhereUniqueWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.CommentUpdateWithWhereUniqueWithoutUserInput`
 */
export import CommentUpdateWithWhereUniqueWithoutUserInput = Prisma.CommentUpdateWithWhereUniqueWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.CommentUpdateManyWithWhereWithoutUserInput`
 */
export import CommentUpdateManyWithWhereWithoutUserInput = Prisma.CommentUpdateManyWithWhereWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.CommentScalarWhereInput`
 */
export import CommentScalarWhereInput = Prisma.CommentScalarWhereInput

/**
 * @deprecated Renamed to `Prisma.CommentUpsertWithWhereUniqueWithoutUserInput`
 */
export import CommentUpsertWithWhereUniqueWithoutUserInput = Prisma.CommentUpsertWithWhereUniqueWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.SubscriptionUpdateWithWhereUniqueWithoutSubscriberInput`
 */
export import SubscriptionUpdateWithWhereUniqueWithoutSubscriberInput = Prisma.SubscriptionUpdateWithWhereUniqueWithoutSubscriberInput

/**
 * @deprecated Renamed to `Prisma.SubscriptionUpdateManyWithWhereWithoutSubscriberInput`
 */
export import SubscriptionUpdateManyWithWhereWithoutSubscriberInput = Prisma.SubscriptionUpdateManyWithWhereWithoutSubscriberInput

/**
 * @deprecated Renamed to `Prisma.SubscriptionScalarWhereInput`
 */
export import SubscriptionScalarWhereInput = Prisma.SubscriptionScalarWhereInput

/**
 * @deprecated Renamed to `Prisma.SubscriptionUpsertWithWhereUniqueWithoutSubscriberInput`
 */
export import SubscriptionUpsertWithWhereUniqueWithoutSubscriberInput = Prisma.SubscriptionUpsertWithWhereUniqueWithoutSubscriberInput

/**
 * @deprecated Renamed to `Prisma.SubscriptionUpdateWithWhereUniqueWithoutSubscribedToInput`
 */
export import SubscriptionUpdateWithWhereUniqueWithoutSubscribedToInput = Prisma.SubscriptionUpdateWithWhereUniqueWithoutSubscribedToInput

/**
 * @deprecated Renamed to `Prisma.SubscriptionUpdateManyWithWhereWithoutSubscribedToInput`
 */
export import SubscriptionUpdateManyWithWhereWithoutSubscribedToInput = Prisma.SubscriptionUpdateManyWithWhereWithoutSubscribedToInput

/**
 * @deprecated Renamed to `Prisma.SubscriptionUpsertWithWhereUniqueWithoutSubscribedToInput`
 */
export import SubscriptionUpsertWithWhereUniqueWithoutSubscribedToInput = Prisma.SubscriptionUpsertWithWhereUniqueWithoutSubscribedToInput

/**
 * @deprecated Renamed to `Prisma.ViewUpdateWithWhereUniqueWithoutUserInput`
 */
export import ViewUpdateWithWhereUniqueWithoutUserInput = Prisma.ViewUpdateWithWhereUniqueWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.ViewUpdateManyWithWhereWithoutUserInput`
 */
export import ViewUpdateManyWithWhereWithoutUserInput = Prisma.ViewUpdateManyWithWhereWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.ViewScalarWhereInput`
 */
export import ViewScalarWhereInput = Prisma.ViewScalarWhereInput

/**
 * @deprecated Renamed to `Prisma.ViewUpsertWithWhereUniqueWithoutUserInput`
 */
export import ViewUpsertWithWhereUniqueWithoutUserInput = Prisma.ViewUpsertWithWhereUniqueWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.UserCreateWithoutCommentsInput`
 */
export import UserCreateWithoutCommentsInput = Prisma.UserCreateWithoutCommentsInput

/**
 * @deprecated Renamed to `Prisma.UserCreateOrConnectWithoutcommentsInput`
 */
export import UserCreateOrConnectWithoutcommentsInput = Prisma.UserCreateOrConnectWithoutcommentsInput

/**
 * @deprecated Renamed to `Prisma.VideoCreateWithoutCommentsInput`
 */
export import VideoCreateWithoutCommentsInput = Prisma.VideoCreateWithoutCommentsInput

/**
 * @deprecated Renamed to `Prisma.VideoCreateOrConnectWithoutcommentsInput`
 */
export import VideoCreateOrConnectWithoutcommentsInput = Prisma.VideoCreateOrConnectWithoutcommentsInput

/**
 * @deprecated Renamed to `Prisma.UserUpdateWithoutCommentsInput`
 */
export import UserUpdateWithoutCommentsInput = Prisma.UserUpdateWithoutCommentsInput

/**
 * @deprecated Renamed to `Prisma.UserUpsertWithoutCommentsInput`
 */
export import UserUpsertWithoutCommentsInput = Prisma.UserUpsertWithoutCommentsInput

/**
 * @deprecated Renamed to `Prisma.VideoUpdateWithoutCommentsInput`
 */
export import VideoUpdateWithoutCommentsInput = Prisma.VideoUpdateWithoutCommentsInput

/**
 * @deprecated Renamed to `Prisma.VideoUpsertWithoutCommentsInput`
 */
export import VideoUpsertWithoutCommentsInput = Prisma.VideoUpsertWithoutCommentsInput

/**
 * @deprecated Renamed to `Prisma.UserCreateWithoutSubscribersInput`
 */
export import UserCreateWithoutSubscribersInput = Prisma.UserCreateWithoutSubscribersInput

/**
 * @deprecated Renamed to `Prisma.UserCreateOrConnectWithoutsubscribersInput`
 */
export import UserCreateOrConnectWithoutsubscribersInput = Prisma.UserCreateOrConnectWithoutsubscribersInput

/**
 * @deprecated Renamed to `Prisma.UserCreateWithoutSubscribedToInput`
 */
export import UserCreateWithoutSubscribedToInput = Prisma.UserCreateWithoutSubscribedToInput

/**
 * @deprecated Renamed to `Prisma.UserCreateOrConnectWithoutsubscribedToInput`
 */
export import UserCreateOrConnectWithoutsubscribedToInput = Prisma.UserCreateOrConnectWithoutsubscribedToInput

/**
 * @deprecated Renamed to `Prisma.UserUpdateWithoutSubscribersInput`
 */
export import UserUpdateWithoutSubscribersInput = Prisma.UserUpdateWithoutSubscribersInput

/**
 * @deprecated Renamed to `Prisma.UserUpsertWithoutSubscribersInput`
 */
export import UserUpsertWithoutSubscribersInput = Prisma.UserUpsertWithoutSubscribersInput

/**
 * @deprecated Renamed to `Prisma.UserUpdateWithoutSubscribedToInput`
 */
export import UserUpdateWithoutSubscribedToInput = Prisma.UserUpdateWithoutSubscribedToInput

/**
 * @deprecated Renamed to `Prisma.UserUpsertWithoutSubscribedToInput`
 */
export import UserUpsertWithoutSubscribedToInput = Prisma.UserUpsertWithoutSubscribedToInput

/**
 * @deprecated Renamed to `Prisma.UserCreateWithoutVideosInput`
 */
export import UserCreateWithoutVideosInput = Prisma.UserCreateWithoutVideosInput

/**
 * @deprecated Renamed to `Prisma.UserCreateOrConnectWithoutvideosInput`
 */
export import UserCreateOrConnectWithoutvideosInput = Prisma.UserCreateOrConnectWithoutvideosInput

/**
 * @deprecated Renamed to `Prisma.VideoLikeCreateWithoutVideoInput`
 */
export import VideoLikeCreateWithoutVideoInput = Prisma.VideoLikeCreateWithoutVideoInput

/**
 * @deprecated Renamed to `Prisma.VideoLikeCreateOrConnectWithoutvideoInput`
 */
export import VideoLikeCreateOrConnectWithoutvideoInput = Prisma.VideoLikeCreateOrConnectWithoutvideoInput

/**
 * @deprecated Renamed to `Prisma.CommentCreateWithoutVideoInput`
 */
export import CommentCreateWithoutVideoInput = Prisma.CommentCreateWithoutVideoInput

/**
 * @deprecated Renamed to `Prisma.CommentCreateOrConnectWithoutvideoInput`
 */
export import CommentCreateOrConnectWithoutvideoInput = Prisma.CommentCreateOrConnectWithoutvideoInput

/**
 * @deprecated Renamed to `Prisma.ViewCreateWithoutVideoInput`
 */
export import ViewCreateWithoutVideoInput = Prisma.ViewCreateWithoutVideoInput

/**
 * @deprecated Renamed to `Prisma.ViewCreateOrConnectWithoutvideoInput`
 */
export import ViewCreateOrConnectWithoutvideoInput = Prisma.ViewCreateOrConnectWithoutvideoInput

/**
 * @deprecated Renamed to `Prisma.UserUpdateWithoutVideosInput`
 */
export import UserUpdateWithoutVideosInput = Prisma.UserUpdateWithoutVideosInput

/**
 * @deprecated Renamed to `Prisma.UserUpsertWithoutVideosInput`
 */
export import UserUpsertWithoutVideosInput = Prisma.UserUpsertWithoutVideosInput

/**
 * @deprecated Renamed to `Prisma.VideoLikeUpdateWithWhereUniqueWithoutVideoInput`
 */
export import VideoLikeUpdateWithWhereUniqueWithoutVideoInput = Prisma.VideoLikeUpdateWithWhereUniqueWithoutVideoInput

/**
 * @deprecated Renamed to `Prisma.VideoLikeUpdateManyWithWhereWithoutVideoInput`
 */
export import VideoLikeUpdateManyWithWhereWithoutVideoInput = Prisma.VideoLikeUpdateManyWithWhereWithoutVideoInput

/**
 * @deprecated Renamed to `Prisma.VideoLikeUpsertWithWhereUniqueWithoutVideoInput`
 */
export import VideoLikeUpsertWithWhereUniqueWithoutVideoInput = Prisma.VideoLikeUpsertWithWhereUniqueWithoutVideoInput

/**
 * @deprecated Renamed to `Prisma.CommentUpdateWithWhereUniqueWithoutVideoInput`
 */
export import CommentUpdateWithWhereUniqueWithoutVideoInput = Prisma.CommentUpdateWithWhereUniqueWithoutVideoInput

/**
 * @deprecated Renamed to `Prisma.CommentUpdateManyWithWhereWithoutVideoInput`
 */
export import CommentUpdateManyWithWhereWithoutVideoInput = Prisma.CommentUpdateManyWithWhereWithoutVideoInput

/**
 * @deprecated Renamed to `Prisma.CommentUpsertWithWhereUniqueWithoutVideoInput`
 */
export import CommentUpsertWithWhereUniqueWithoutVideoInput = Prisma.CommentUpsertWithWhereUniqueWithoutVideoInput

/**
 * @deprecated Renamed to `Prisma.ViewUpdateWithWhereUniqueWithoutVideoInput`
 */
export import ViewUpdateWithWhereUniqueWithoutVideoInput = Prisma.ViewUpdateWithWhereUniqueWithoutVideoInput

/**
 * @deprecated Renamed to `Prisma.ViewUpdateManyWithWhereWithoutVideoInput`
 */
export import ViewUpdateManyWithWhereWithoutVideoInput = Prisma.ViewUpdateManyWithWhereWithoutVideoInput

/**
 * @deprecated Renamed to `Prisma.ViewUpsertWithWhereUniqueWithoutVideoInput`
 */
export import ViewUpsertWithWhereUniqueWithoutVideoInput = Prisma.ViewUpsertWithWhereUniqueWithoutVideoInput

/**
 * @deprecated Renamed to `Prisma.UserCreateWithoutVideoLikesInput`
 */
export import UserCreateWithoutVideoLikesInput = Prisma.UserCreateWithoutVideoLikesInput

/**
 * @deprecated Renamed to `Prisma.UserCreateOrConnectWithoutvideoLikesInput`
 */
export import UserCreateOrConnectWithoutvideoLikesInput = Prisma.UserCreateOrConnectWithoutvideoLikesInput

/**
 * @deprecated Renamed to `Prisma.VideoCreateWithoutVideoLikesInput`
 */
export import VideoCreateWithoutVideoLikesInput = Prisma.VideoCreateWithoutVideoLikesInput

/**
 * @deprecated Renamed to `Prisma.VideoCreateOrConnectWithoutvideoLikesInput`
 */
export import VideoCreateOrConnectWithoutvideoLikesInput = Prisma.VideoCreateOrConnectWithoutvideoLikesInput

/**
 * @deprecated Renamed to `Prisma.UserUpdateWithoutVideoLikesInput`
 */
export import UserUpdateWithoutVideoLikesInput = Prisma.UserUpdateWithoutVideoLikesInput

/**
 * @deprecated Renamed to `Prisma.UserUpsertWithoutVideoLikesInput`
 */
export import UserUpsertWithoutVideoLikesInput = Prisma.UserUpsertWithoutVideoLikesInput

/**
 * @deprecated Renamed to `Prisma.VideoUpdateWithoutVideoLikesInput`
 */
export import VideoUpdateWithoutVideoLikesInput = Prisma.VideoUpdateWithoutVideoLikesInput

/**
 * @deprecated Renamed to `Prisma.VideoUpsertWithoutVideoLikesInput`
 */
export import VideoUpsertWithoutVideoLikesInput = Prisma.VideoUpsertWithoutVideoLikesInput

/**
 * @deprecated Renamed to `Prisma.UserCreateWithoutViewsInput`
 */
export import UserCreateWithoutViewsInput = Prisma.UserCreateWithoutViewsInput

/**
 * @deprecated Renamed to `Prisma.UserCreateOrConnectWithoutviewsInput`
 */
export import UserCreateOrConnectWithoutviewsInput = Prisma.UserCreateOrConnectWithoutviewsInput

/**
 * @deprecated Renamed to `Prisma.VideoCreateWithoutViewsInput`
 */
export import VideoCreateWithoutViewsInput = Prisma.VideoCreateWithoutViewsInput

/**
 * @deprecated Renamed to `Prisma.VideoCreateOrConnectWithoutviewsInput`
 */
export import VideoCreateOrConnectWithoutviewsInput = Prisma.VideoCreateOrConnectWithoutviewsInput

/**
 * @deprecated Renamed to `Prisma.UserUpdateWithoutViewsInput`
 */
export import UserUpdateWithoutViewsInput = Prisma.UserUpdateWithoutViewsInput

/**
 * @deprecated Renamed to `Prisma.UserUpsertWithoutViewsInput`
 */
export import UserUpsertWithoutViewsInput = Prisma.UserUpsertWithoutViewsInput

/**
 * @deprecated Renamed to `Prisma.VideoUpdateWithoutViewsInput`
 */
export import VideoUpdateWithoutViewsInput = Prisma.VideoUpdateWithoutViewsInput

/**
 * @deprecated Renamed to `Prisma.VideoUpsertWithoutViewsInput`
 */
export import VideoUpsertWithoutViewsInput = Prisma.VideoUpsertWithoutViewsInput

/**
 * @deprecated Renamed to `Prisma.VideoUpdateWithoutUserInput`
 */
export import VideoUpdateWithoutUserInput = Prisma.VideoUpdateWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.VideoLikeUpdateWithoutUserInput`
 */
export import VideoLikeUpdateWithoutUserInput = Prisma.VideoLikeUpdateWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.CommentUpdateWithoutUserInput`
 */
export import CommentUpdateWithoutUserInput = Prisma.CommentUpdateWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.SubscriptionUpdateWithoutSubscriberInput`
 */
export import SubscriptionUpdateWithoutSubscriberInput = Prisma.SubscriptionUpdateWithoutSubscriberInput

/**
 * @deprecated Renamed to `Prisma.SubscriptionUpdateWithoutSubscribedToInput`
 */
export import SubscriptionUpdateWithoutSubscribedToInput = Prisma.SubscriptionUpdateWithoutSubscribedToInput

/**
 * @deprecated Renamed to `Prisma.ViewUpdateWithoutUserInput`
 */
export import ViewUpdateWithoutUserInput = Prisma.ViewUpdateWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.VideoLikeUpdateWithoutVideoInput`
 */
export import VideoLikeUpdateWithoutVideoInput = Prisma.VideoLikeUpdateWithoutVideoInput

/**
 * @deprecated Renamed to `Prisma.CommentUpdateWithoutVideoInput`
 */
export import CommentUpdateWithoutVideoInput = Prisma.CommentUpdateWithoutVideoInput

/**
 * @deprecated Renamed to `Prisma.ViewUpdateWithoutVideoInput`
 */
export import ViewUpdateWithoutVideoInput = Prisma.ViewUpdateWithoutVideoInput